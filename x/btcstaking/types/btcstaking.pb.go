// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: babylon/btcstaking/v1/btcstaking.proto

package types

import (
	fmt "fmt"
	github_com_babylonchain_babylon_types "github.com/babylonchain/babylon/types"
	secp256k1 "github.com/cosmos/cosmos-sdk/crypto/keys/secp256k1"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// BTCValidator defines a BTC validator
type BTCValidator struct {
	// babylon_pk is the Babylon secp256k1 PK of this BTC validator
	BabylonPk *secp256k1.PubKey `protobuf:"bytes,1,opt,name=babylon_pk,json=babylonPk,proto3" json:"babylon_pk,omitempty"`
	// btc_pk is the Bitcoin secp256k1 PK of this BTC validator
	// the PK follows encoding in BIP-340 spec
	BtcPk *github_com_babylonchain_babylon_types.BIP340PubKey `protobuf:"bytes,2,opt,name=btc_pk,json=btcPk,proto3,customtype=github.com/babylonchain/babylon/types.BIP340PubKey" json:"btc_pk,omitempty"`
	// pop is the proof of possession of babylon_pk and btc_pk
	Pop *ProofOfPossession `protobuf:"bytes,3,opt,name=pop,proto3" json:"pop,omitempty"`
}

func (m *BTCValidator) Reset()         { *m = BTCValidator{} }
func (m *BTCValidator) String() string { return proto.CompactTextString(m) }
func (*BTCValidator) ProtoMessage()    {}
func (*BTCValidator) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{0}
}
func (m *BTCValidator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BTCValidator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BTCValidator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BTCValidator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BTCValidator.Merge(m, src)
}
func (m *BTCValidator) XXX_Size() int {
	return m.Size()
}
func (m *BTCValidator) XXX_DiscardUnknown() {
	xxx_messageInfo_BTCValidator.DiscardUnknown(m)
}

var xxx_messageInfo_BTCValidator proto.InternalMessageInfo

func (m *BTCValidator) GetBabylonPk() *secp256k1.PubKey {
	if m != nil {
		return m.BabylonPk
	}
	return nil
}

func (m *BTCValidator) GetPop() *ProofOfPossession {
	if m != nil {
		return m.Pop
	}
	return nil
}

// BTCDelegation defines a BTC delegation
type BTCDelegation struct {
	// babylon_pk is the Babylon secp256k1 PK of this BTC delegation
	BabylonPk *secp256k1.PubKey `protobuf:"bytes,1,opt,name=babylon_pk,json=babylonPk,proto3" json:"babylon_pk,omitempty"`
	// btc_pk is the Bitcoin secp256k1 PK of this BTC delegation
	// the PK follows encoding in BIP-340 spec
	BtcPk *github_com_babylonchain_babylon_types.BIP340PubKey `protobuf:"bytes,2,opt,name=btc_pk,json=btcPk,proto3,customtype=github.com/babylonchain/babylon/types.BIP340PubKey" json:"btc_pk,omitempty"`
	// pop is the proof of possession of babylon_pk and btc_pk
	Pop *ProofOfPossession `protobuf:"bytes,3,opt,name=pop,proto3" json:"pop,omitempty"`
	// val_btc_pk is the Bitcoin secp256k1 PK of the BTC validator that
	// this BTC delegation delegates to
	// the PK follows encoding in BIP-340 spec
	ValBtcPk *github_com_babylonchain_babylon_types.BIP340PubKey `protobuf:"bytes,4,opt,name=val_btc_pk,json=valBtcPk,proto3,customtype=github.com/babylonchain/babylon/types.BIP340PubKey" json:"val_btc_pk,omitempty"`
	// start_height is the start BTC height of the BTC delegation
	// it is the start BTC height of the timelock
	StartHeight uint64 `protobuf:"varint,5,opt,name=start_height,json=startHeight,proto3" json:"start_height,omitempty"`
	// end_height is the end height of the BTC delegation
	// it is the end BTC height of the timelock - w
	EndHeight uint64 `protobuf:"varint,6,opt,name=end_height,json=endHeight,proto3" json:"end_height,omitempty"`
	// total_sat is the total amount of BTC stakes in this delegation
	// quantified in satoshi
	TotalSat uint64 `protobuf:"varint,7,opt,name=total_sat,json=totalSat,proto3" json:"total_sat,omitempty"`
	// staking_tx is the staking tx
	StakingTx *StakingTx `protobuf:"bytes,8,opt,name=staking_tx,json=stakingTx,proto3" json:"staking_tx,omitempty"`
	// slashing_tx is the slashing tx
	// It is partially signed by SK corresponding to btc_pk, but not signed by
	// validator or jury yet.
	SlashingTx *BTCSlashingTx `protobuf:"bytes,9,opt,name=slashing_tx,json=slashingTx,proto3,customtype=BTCSlashingTx" json:"slashing_tx,omitempty"`
	// delegator_sig is the signature on the slashing tx
	// by the delegator (i.e., SK corresponding to btc_pk).
	// It will be a part of the witness for the staking tx output.
	DelegatorSig *github_com_babylonchain_babylon_types.BIP340Signature `protobuf:"bytes,10,opt,name=delegator_sig,json=delegatorSig,proto3,customtype=github.com/babylonchain/babylon/types.BIP340Signature" json:"delegator_sig,omitempty"`
	// jury_sig is the signature signature on the slashing tx
	// by the jury (i.e., SK corresponding to jury_pk in params)
	// It will be a part of the witness for the staking tx output.
	JurySig *github_com_babylonchain_babylon_types.BIP340Signature `protobuf:"bytes,11,opt,name=jury_sig,json=jurySig,proto3,customtype=github.com/babylonchain/babylon/types.BIP340Signature" json:"jury_sig,omitempty"`
}

func (m *BTCDelegation) Reset()         { *m = BTCDelegation{} }
func (m *BTCDelegation) String() string { return proto.CompactTextString(m) }
func (*BTCDelegation) ProtoMessage()    {}
func (*BTCDelegation) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{1}
}
func (m *BTCDelegation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BTCDelegation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BTCDelegation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BTCDelegation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BTCDelegation.Merge(m, src)
}
func (m *BTCDelegation) XXX_Size() int {
	return m.Size()
}
func (m *BTCDelegation) XXX_DiscardUnknown() {
	xxx_messageInfo_BTCDelegation.DiscardUnknown(m)
}

var xxx_messageInfo_BTCDelegation proto.InternalMessageInfo

func (m *BTCDelegation) GetBabylonPk() *secp256k1.PubKey {
	if m != nil {
		return m.BabylonPk
	}
	return nil
}

func (m *BTCDelegation) GetPop() *ProofOfPossession {
	if m != nil {
		return m.Pop
	}
	return nil
}

func (m *BTCDelegation) GetStartHeight() uint64 {
	if m != nil {
		return m.StartHeight
	}
	return 0
}

func (m *BTCDelegation) GetEndHeight() uint64 {
	if m != nil {
		return m.EndHeight
	}
	return 0
}

func (m *BTCDelegation) GetTotalSat() uint64 {
	if m != nil {
		return m.TotalSat
	}
	return 0
}

func (m *BTCDelegation) GetStakingTx() *StakingTx {
	if m != nil {
		return m.StakingTx
	}
	return nil
}

// ProofOfPossession is the proof of possession that a Babylon secp256k1
// secret key and a Bitcoin secp256k1 secret key are held by the same
// person
type ProofOfPossession struct {
	// babylon_sig is the signature generated via sign(sk_babylon, pk_btc)
	BabylonSig []byte `protobuf:"bytes,1,opt,name=babylon_sig,json=babylonSig,proto3" json:"babylon_sig,omitempty"`
	// btc_sig is the signature generated via sign(sk_btc, babylon_sig)
	// the signature follows encoding in BIP-340 spec
	BtcSig *github_com_babylonchain_babylon_types.BIP340Signature `protobuf:"bytes,2,opt,name=btc_sig,json=btcSig,proto3,customtype=github.com/babylonchain/babylon/types.BIP340Signature" json:"btc_sig,omitempty"`
}

func (m *ProofOfPossession) Reset()         { *m = ProofOfPossession{} }
func (m *ProofOfPossession) String() string { return proto.CompactTextString(m) }
func (*ProofOfPossession) ProtoMessage()    {}
func (*ProofOfPossession) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{2}
}
func (m *ProofOfPossession) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProofOfPossession) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProofOfPossession.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProofOfPossession) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProofOfPossession.Merge(m, src)
}
func (m *ProofOfPossession) XXX_Size() int {
	return m.Size()
}
func (m *ProofOfPossession) XXX_DiscardUnknown() {
	xxx_messageInfo_ProofOfPossession.DiscardUnknown(m)
}

var xxx_messageInfo_ProofOfPossession proto.InternalMessageInfo

func (m *ProofOfPossession) GetBabylonSig() []byte {
	if m != nil {
		return m.BabylonSig
	}
	return nil
}

// StakingTx is the tx for delegating BTC
type StakingTx struct {
	// tx is the staking tx in bytes
	Tx []byte `protobuf:"bytes,1,opt,name=tx,proto3" json:"tx,omitempty"`
	// staking_script is the script for the staking tx's output
	StakingScript []byte `protobuf:"bytes,2,opt,name=staking_script,json=stakingScript,proto3" json:"staking_script,omitempty"`
}

func (m *StakingTx) Reset()         { *m = StakingTx{} }
func (m *StakingTx) String() string { return proto.CompactTextString(m) }
func (*StakingTx) ProtoMessage()    {}
func (*StakingTx) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{3}
}
func (m *StakingTx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StakingTx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StakingTx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StakingTx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StakingTx.Merge(m, src)
}
func (m *StakingTx) XXX_Size() int {
	return m.Size()
}
func (m *StakingTx) XXX_DiscardUnknown() {
	xxx_messageInfo_StakingTx.DiscardUnknown(m)
}

var xxx_messageInfo_StakingTx proto.InternalMessageInfo

func (m *StakingTx) GetTx() []byte {
	if m != nil {
		return m.Tx
	}
	return nil
}

func (m *StakingTx) GetStakingScript() []byte {
	if m != nil {
		return m.StakingScript
	}
	return nil
}

func init() {
	proto.RegisterType((*BTCValidator)(nil), "babylon.btcstaking.v1.BTCValidator")
	proto.RegisterType((*BTCDelegation)(nil), "babylon.btcstaking.v1.BTCDelegation")
	proto.RegisterType((*ProofOfPossession)(nil), "babylon.btcstaking.v1.ProofOfPossession")
	proto.RegisterType((*StakingTx)(nil), "babylon.btcstaking.v1.StakingTx")
}

func init() {
	proto.RegisterFile("babylon/btcstaking/v1/btcstaking.proto", fileDescriptor_3851ae95ccfaf7db)
}

var fileDescriptor_3851ae95ccfaf7db = []byte{
	// 575 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x54, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xae, 0xd3, 0xbf, 0x64, 0x92, 0x56, 0xea, 0x0a, 0xa4, 0xa8, 0x08, 0x27, 0x44, 0x02, 0xe5,
	0x64, 0xd3, 0x94, 0x56, 0x82, 0x03, 0x48, 0x2e, 0x07, 0x10, 0x20, 0x2c, 0xdb, 0xe2, 0xc0, 0x01,
	0x6b, 0xed, 0xb8, 0xce, 0x62, 0xd7, 0x6b, 0x79, 0x37, 0x91, 0xfd, 0x06, 0x1c, 0x79, 0x1e, 0x9e,
	0x80, 0x63, 0x8f, 0xd0, 0x43, 0x85, 0xda, 0x17, 0x41, 0xbb, 0x5e, 0x47, 0x95, 0x00, 0x21, 0x94,
	0x1b, 0xb7, 0xf1, 0xcc, 0x37, 0xdf, 0x7c, 0xe3, 0xf9, 0xb4, 0xf0, 0x20, 0xc0, 0x41, 0x95, 0xd2,
	0xcc, 0x0c, 0x78, 0xc8, 0x38, 0x4e, 0x48, 0x16, 0x9b, 0x8b, 0x83, 0x1b, 0x5f, 0x46, 0x5e, 0x50,
	0x4e, 0xd1, 0x6d, 0x85, 0x33, 0x6e, 0x54, 0x16, 0x07, 0xfb, 0xb7, 0x62, 0x1a, 0x53, 0x89, 0x30,
	0x45, 0x54, 0x83, 0xf7, 0x47, 0x21, 0x65, 0x67, 0x94, 0x99, 0x61, 0x51, 0xe5, 0x9c, 0x9a, 0x2c,
	0x0a, 0xf3, 0xc9, 0xd1, 0x71, 0x72, 0x60, 0x26, 0x51, 0xc5, 0x6a, 0xcc, 0xe8, 0xbb, 0x06, 0x3d,
	0xcb, 0x3b, 0x79, 0x87, 0x53, 0x32, 0xc5, 0x9c, 0x16, 0xe8, 0x29, 0x80, 0x9a, 0xe1, 0xe7, 0x49,
	0x5f, 0x1b, 0x6a, 0xe3, 0xee, 0x64, 0x60, 0xd4, 0x4c, 0x46, 0xcd, 0x64, 0x2c, 0x99, 0x0c, 0x7b,
	0x1e, 0xbc, 0x8a, 0x2a, 0xa7, 0xa3, 0x5a, 0xec, 0x04, 0xbd, 0x81, 0xad, 0x80, 0x87, 0xa2, 0xb7,
	0x35, 0xd4, 0xc6, 0x3d, 0xeb, 0xf8, 0xe2, 0x72, 0x30, 0x89, 0x09, 0x9f, 0xcd, 0x03, 0x23, 0xa4,
	0x67, 0xa6, 0x42, 0x86, 0x33, 0x4c, 0xb2, 0xe6, 0xc3, 0xe4, 0x55, 0x1e, 0x31, 0xc3, 0x7a, 0x69,
	0x1f, 0x3e, 0x7a, 0xa8, 0x28, 0x37, 0x03, 0x1e, 0xda, 0x09, 0x7a, 0x02, 0xeb, 0x39, 0xcd, 0xfb,
	0xeb, 0x52, 0xc7, 0xd8, 0xf8, 0xed, 0xfa, 0x86, 0x5d, 0x50, 0x7a, 0xfa, 0xf6, 0xd4, 0xa6, 0x8c,
	0x45, 0x8c, 0x11, 0x9a, 0x39, 0xa2, 0x69, 0xf4, 0x65, 0x13, 0x76, 0x2c, 0xef, 0xe4, 0x79, 0x94,
	0x46, 0x31, 0xe6, 0x84, 0x66, 0xff, 0xd1, 0x72, 0xc8, 0x03, 0x58, 0xe0, 0xd4, 0x57, 0x72, 0x36,
	0x56, 0x92, 0xd3, 0x5e, 0xe0, 0xd4, 0x92, 0x8a, 0xee, 0x41, 0x8f, 0x71, 0x5c, 0x70, 0x7f, 0x16,
	0x91, 0x78, 0xc6, 0xfb, 0x9b, 0x43, 0x6d, 0xbc, 0xe1, 0x74, 0x65, 0xee, 0x85, 0x4c, 0xa1, 0xbb,
	0x00, 0x51, 0x36, 0x6d, 0x00, 0x5b, 0x12, 0xd0, 0x89, 0xb2, 0xa9, 0x2a, 0xdf, 0x81, 0x0e, 0xa7,
	0x1c, 0xa7, 0x3e, 0xc3, 0xbc, 0xbf, 0x2d, 0xab, 0x6d, 0x99, 0x70, 0x31, 0x47, 0xcf, 0x00, 0xd4,
	0x66, 0x3e, 0x2f, 0xfb, 0x6d, 0xb9, 0xf7, 0xf0, 0x0f, 0x7b, 0xbb, 0x75, 0xe8, 0x95, 0x4e, 0x87,
	0x35, 0x21, 0x9a, 0x40, 0x97, 0xa5, 0x98, 0xcd, 0x14, 0x43, 0x47, 0xae, 0xbd, 0x77, 0x71, 0x39,
	0x10, 0x87, 0x76, 0x55, 0xc5, 0x2b, 0x1d, 0x60, 0xcb, 0x18, 0x7d, 0x80, 0x9d, 0x69, 0x6d, 0x01,
	0x5a, 0xf8, 0x8c, 0xc4, 0x7d, 0x90, 0x5d, 0x8f, 0x2f, 0x2e, 0x07, 0x47, 0xff, 0xf2, 0xb3, 0x5c,
	0x12, 0x67, 0x98, 0xcf, 0x8b, 0xc8, 0xe9, 0x2d, 0xf9, 0x5c, 0x12, 0x23, 0x0f, 0xda, 0x1f, 0xe7,
	0x45, 0x25, 0xa9, 0xbb, 0xab, 0x52, 0x6f, 0x0b, 0x2a, 0x97, 0xc4, 0xa3, 0x4f, 0x1a, 0xec, 0xfd,
	0x72, 0x7a, 0x34, 0x80, 0x6e, 0x63, 0x60, 0x31, 0x4e, 0x38, 0xb8, 0xe7, 0x34, 0x9e, 0x16, 0x62,
	0x1c, 0xd8, 0x16, 0x96, 0x10, 0xc5, 0xd6, 0xaa, 0x5a, 0x84, 0xd7, 0x85, 0x14, 0x0b, 0x3a, 0xcb,
	0x63, 0xa0, 0x5d, 0x68, 0xf1, 0x52, 0x0d, 0x6e, 0xf1, 0x12, 0xdd, 0x87, 0xdd, 0xe6, 0xa4, 0x2c,
	0x2c, 0x48, 0xce, 0xeb, 0xb9, 0xce, 0x8e, 0xca, 0xba, 0x32, 0x69, 0xbd, 0xfe, 0x7a, 0xa5, 0x6b,
	0xe7, 0x57, 0xba, 0xf6, 0xe3, 0x4a, 0xd7, 0x3e, 0x5f, 0xeb, 0x6b, 0xe7, 0xd7, 0xfa, 0xda, 0xb7,
	0x6b, 0x7d, 0xed, 0xfd, 0x5f, 0x0d, 0x5b, 0xde, 0x7c, 0x14, 0xa5, 0xd2, 0x60, 0x4b, 0x3e, 0x5e,
	0x87, 0x3f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x6a, 0x32, 0x65, 0xa2, 0x37, 0x05, 0x00, 0x00,
}

func (m *BTCValidator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BTCValidator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCValidator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pop != nil {
		{
			size, err := m.Pop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.BtcPk != nil {
		{
			size := m.BtcPk.Size()
			i -= size
			if _, err := m.BtcPk.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BabylonPk != nil {
		{
			size, err := m.BabylonPk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BTCDelegation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BTCDelegation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCDelegation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.JurySig != nil {
		{
			size := m.JurySig.Size()
			i -= size
			if _, err := m.JurySig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.DelegatorSig != nil {
		{
			size := m.DelegatorSig.Size()
			i -= size
			if _, err := m.DelegatorSig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.SlashingTx != nil {
		{
			size := m.SlashingTx.Size()
			i -= size
			if _, err := m.SlashingTx.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.StakingTx != nil {
		{
			size, err := m.StakingTx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.TotalSat != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.TotalSat))
		i--
		dAtA[i] = 0x38
	}
	if m.EndHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.EndHeight))
		i--
		dAtA[i] = 0x30
	}
	if m.StartHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.StartHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.ValBtcPk != nil {
		{
			size := m.ValBtcPk.Size()
			i -= size
			if _, err := m.ValBtcPk.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Pop != nil {
		{
			size, err := m.Pop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.BtcPk != nil {
		{
			size := m.BtcPk.Size()
			i -= size
			if _, err := m.BtcPk.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BabylonPk != nil {
		{
			size, err := m.BabylonPk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProofOfPossession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProofOfPossession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProofOfPossession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BtcSig != nil {
		{
			size := m.BtcSig.Size()
			i -= size
			if _, err := m.BtcSig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.BabylonSig) > 0 {
		i -= len(m.BabylonSig)
		copy(dAtA[i:], m.BabylonSig)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.BabylonSig)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StakingTx) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StakingTx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StakingTx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StakingScript) > 0 {
		i -= len(m.StakingScript)
		copy(dAtA[i:], m.StakingScript)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.StakingScript)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Tx) > 0 {
		i -= len(m.Tx)
		copy(dAtA[i:], m.Tx)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.Tx)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintBtcstaking(dAtA []byte, offset int, v uint64) int {
	offset -= sovBtcstaking(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BTCValidator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BabylonPk != nil {
		l = m.BabylonPk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.BtcPk != nil {
		l = m.BtcPk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.Pop != nil {
		l = m.Pop.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func (m *BTCDelegation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BabylonPk != nil {
		l = m.BabylonPk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.BtcPk != nil {
		l = m.BtcPk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.Pop != nil {
		l = m.Pop.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.ValBtcPk != nil {
		l = m.ValBtcPk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.StartHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.StartHeight))
	}
	if m.EndHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.EndHeight))
	}
	if m.TotalSat != 0 {
		n += 1 + sovBtcstaking(uint64(m.TotalSat))
	}
	if m.StakingTx != nil {
		l = m.StakingTx.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.SlashingTx != nil {
		l = m.SlashingTx.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.DelegatorSig != nil {
		l = m.DelegatorSig.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.JurySig != nil {
		l = m.JurySig.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func (m *ProofOfPossession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BabylonSig)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.BtcSig != nil {
		l = m.BtcSig.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func (m *StakingTx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tx)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	l = len(m.StakingScript)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func sovBtcstaking(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBtcstaking(x uint64) (n int) {
	return sovBtcstaking(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BTCValidator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BTCValidator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BTCValidator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BabylonPk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BabylonPk == nil {
				m.BabylonPk = &secp256k1.PubKey{}
			}
			if err := m.BabylonPk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcPk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340PubKey
			m.BtcPk = &v
			if err := m.BtcPk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pop == nil {
				m.Pop = &ProofOfPossession{}
			}
			if err := m.Pop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BTCDelegation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BTCDelegation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BTCDelegation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BabylonPk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BabylonPk == nil {
				m.BabylonPk = &secp256k1.PubKey{}
			}
			if err := m.BabylonPk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcPk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340PubKey
			m.BtcPk = &v
			if err := m.BtcPk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pop == nil {
				m.Pop = &ProofOfPossession{}
			}
			if err := m.Pop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValBtcPk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340PubKey
			m.ValBtcPk = &v
			if err := m.ValBtcPk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartHeight", wireType)
			}
			m.StartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndHeight", wireType)
			}
			m.EndHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSat", wireType)
			}
			m.TotalSat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSat |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakingTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StakingTx == nil {
				m.StakingTx = &StakingTx{}
			}
			if err := m.StakingTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashingTx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v BTCSlashingTx
			m.SlashingTx = &v
			if err := m.SlashingTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340Signature
			m.DelegatorSig = &v
			if err := m.DelegatorSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JurySig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340Signature
			m.JurySig = &v
			if err := m.JurySig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProofOfPossession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProofOfPossession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProofOfPossession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BabylonSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BabylonSig = append(m.BabylonSig[:0], dAtA[iNdEx:postIndex]...)
			if m.BabylonSig == nil {
				m.BabylonSig = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340Signature
			m.BtcSig = &v
			if err := m.BtcSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StakingTx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StakingTx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StakingTx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tx = append(m.Tx[:0], dAtA[iNdEx:postIndex]...)
			if m.Tx == nil {
				m.Tx = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakingScript", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakingScript = append(m.StakingScript[:0], dAtA[iNdEx:postIndex]...)
			if m.StakingScript == nil {
				m.StakingScript = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBtcstaking(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBtcstaking
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBtcstaking
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBtcstaking
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBtcstaking        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBtcstaking          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBtcstaking = fmt.Errorf("proto: unexpected end of group")
)
