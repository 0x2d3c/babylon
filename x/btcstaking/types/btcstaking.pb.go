// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: babylon/btcstaking/v1/btcstaking.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	github_com_babylonchain_babylon_types "github.com/babylonchain/babylon/types"
	_ "github.com/cosmos/cosmos-proto"
	secp256k1 "github.com/cosmos/cosmos-sdk/crypto/keys/secp256k1"
	types "github.com/cosmos/cosmos-sdk/x/staking/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// BTCDelegationStatus is the status of a delegation. There are two possible state
// transition paths:
// 1. PENDING -> ACTIVE -> UNBONDED - this is the typical path when timelock of staking
// transaction expires.
// 2. PENDING _> ACTIVE -> UNBONDING -> UNBONDED - this is the path when staker requests undelegation through
// MsgBTCUndelegate message.
type BTCDelegationStatus int32

const (
	// PENDING defines a delegation that is waiting for a covenant signature to become active.
	BTCDelegationStatus_PENDING BTCDelegationStatus = 0
	// ACTIVE defines a delegation that has voting power
	BTCDelegationStatus_ACTIVE BTCDelegationStatus = 1
	// UNBONDING defines a delegation that is being unbonded i.e it received an unbonding tx
	// from staker, but not yet received signatures from validator and covenant.
	// Delegation in this state already lost its voting power.
	BTCDelegationStatus_UNBONDING BTCDelegationStatus = 2
	// UNBONDED defines a delegation no longer has voting power:
	// - either reaching the end of staking transaction timelock
	// - or receiving unbonding tx and then receiving signatures from validator and covenant for this
	// unbonding tx.
	BTCDelegationStatus_UNBONDED BTCDelegationStatus = 3
	// ANY is any of the above status
	BTCDelegationStatus_ANY BTCDelegationStatus = 4
)

var BTCDelegationStatus_name = map[int32]string{
	0: "PENDING",
	1: "ACTIVE",
	2: "UNBONDING",
	3: "UNBONDED",
	4: "ANY",
}

var BTCDelegationStatus_value = map[string]int32{
	"PENDING":   0,
	"ACTIVE":    1,
	"UNBONDING": 2,
	"UNBONDED":  3,
	"ANY":       4,
}

func (x BTCDelegationStatus) String() string {
	return proto.EnumName(BTCDelegationStatus_name, int32(x))
}

func (BTCDelegationStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{0}
}

// BTCValidator defines a BTC validator
type BTCValidator struct {
	// description defines the description terms for the BTC validator.
	Description *types.Description `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	// commission defines the commission rate of BTC validator.
	Commission *cosmossdk_io_math.LegacyDec `protobuf:"bytes,2,opt,name=commission,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"commission,omitempty"`
	// babylon_pk is the Babylon secp256k1 PK of this BTC validator
	BabylonPk *secp256k1.PubKey `protobuf:"bytes,3,opt,name=babylon_pk,json=babylonPk,proto3" json:"babylon_pk,omitempty"`
	// btc_pk is the Bitcoin secp256k1 PK of this BTC validator
	// the PK follows encoding in BIP-340 spec
	BtcPk *github_com_babylonchain_babylon_types.BIP340PubKey `protobuf:"bytes,4,opt,name=btc_pk,json=btcPk,proto3,customtype=github.com/babylonchain/babylon/types.BIP340PubKey" json:"btc_pk,omitempty"`
	// pop is the proof of possession of babylon_pk and btc_pk
	Pop *ProofOfPossession `protobuf:"bytes,5,opt,name=pop,proto3" json:"pop,omitempty"`
	// slashed_babylon_height indicates the Babylon height when
	// the BTC validator is slashed.
	// if it's 0 then the BTC validator is not slashed
	SlashedBabylonHeight uint64 `protobuf:"varint,6,opt,name=slashed_babylon_height,json=slashedBabylonHeight,proto3" json:"slashed_babylon_height,omitempty"`
	// slashed_btc_height indicates the BTC height when
	// the BTC validator is slashed.
	// if it's 0 then the BTC validator is not slashed
	SlashedBtcHeight uint64 `protobuf:"varint,7,opt,name=slashed_btc_height,json=slashedBtcHeight,proto3" json:"slashed_btc_height,omitempty"`
}

func (m *BTCValidator) Reset()         { *m = BTCValidator{} }
func (m *BTCValidator) String() string { return proto.CompactTextString(m) }
func (*BTCValidator) ProtoMessage()    {}
func (*BTCValidator) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{0}
}
func (m *BTCValidator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BTCValidator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BTCValidator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BTCValidator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BTCValidator.Merge(m, src)
}
func (m *BTCValidator) XXX_Size() int {
	return m.Size()
}
func (m *BTCValidator) XXX_DiscardUnknown() {
	xxx_messageInfo_BTCValidator.DiscardUnknown(m)
}

var xxx_messageInfo_BTCValidator proto.InternalMessageInfo

func (m *BTCValidator) GetDescription() *types.Description {
	if m != nil {
		return m.Description
	}
	return nil
}

func (m *BTCValidator) GetBabylonPk() *secp256k1.PubKey {
	if m != nil {
		return m.BabylonPk
	}
	return nil
}

func (m *BTCValidator) GetPop() *ProofOfPossession {
	if m != nil {
		return m.Pop
	}
	return nil
}

func (m *BTCValidator) GetSlashedBabylonHeight() uint64 {
	if m != nil {
		return m.SlashedBabylonHeight
	}
	return 0
}

func (m *BTCValidator) GetSlashedBtcHeight() uint64 {
	if m != nil {
		return m.SlashedBtcHeight
	}
	return 0
}

// BTCValidatorWithMeta wraps the BTCValidator with meta data.
type BTCValidatorWithMeta struct {
	// btc_pk is the Bitcoin secp256k1 PK of this BTC validator
	// the PK follows encoding in BIP-340 spec
	BtcPk *github_com_babylonchain_babylon_types.BIP340PubKey `protobuf:"bytes,1,opt,name=btc_pk,json=btcPk,proto3,customtype=github.com/babylonchain/babylon/types.BIP340PubKey" json:"btc_pk,omitempty"`
	// height is the queried Babylon height
	Height uint64 `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	// voting_power is the voting power of this BTC validator at the given height
	VotingPower uint64 `protobuf:"varint,3,opt,name=voting_power,json=votingPower,proto3" json:"voting_power,omitempty"`
	// slashed_babylon_height indicates the Babylon height when
	// the BTC validator is slashed.
	// if it's 0 then the BTC validator is not slashed
	SlashedBabylonHeight uint64 `protobuf:"varint,4,opt,name=slashed_babylon_height,json=slashedBabylonHeight,proto3" json:"slashed_babylon_height,omitempty"`
	// slashed_btc_height indicates the BTC height when
	// the BTC validator is slashed.
	// if it's 0 then the BTC validator is not slashed
	SlashedBtcHeight uint64 `protobuf:"varint,5,opt,name=slashed_btc_height,json=slashedBtcHeight,proto3" json:"slashed_btc_height,omitempty"`
}

func (m *BTCValidatorWithMeta) Reset()         { *m = BTCValidatorWithMeta{} }
func (m *BTCValidatorWithMeta) String() string { return proto.CompactTextString(m) }
func (*BTCValidatorWithMeta) ProtoMessage()    {}
func (*BTCValidatorWithMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{1}
}
func (m *BTCValidatorWithMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BTCValidatorWithMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BTCValidatorWithMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BTCValidatorWithMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BTCValidatorWithMeta.Merge(m, src)
}
func (m *BTCValidatorWithMeta) XXX_Size() int {
	return m.Size()
}
func (m *BTCValidatorWithMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_BTCValidatorWithMeta.DiscardUnknown(m)
}

var xxx_messageInfo_BTCValidatorWithMeta proto.InternalMessageInfo

func (m *BTCValidatorWithMeta) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *BTCValidatorWithMeta) GetVotingPower() uint64 {
	if m != nil {
		return m.VotingPower
	}
	return 0
}

func (m *BTCValidatorWithMeta) GetSlashedBabylonHeight() uint64 {
	if m != nil {
		return m.SlashedBabylonHeight
	}
	return 0
}

func (m *BTCValidatorWithMeta) GetSlashedBtcHeight() uint64 {
	if m != nil {
		return m.SlashedBtcHeight
	}
	return 0
}

// BTCDelegation defines a BTC delegation
type BTCDelegation struct {
	// babylon_pk is the Babylon secp256k1 PK of this BTC delegation
	BabylonPk *secp256k1.PubKey `protobuf:"bytes,1,opt,name=babylon_pk,json=babylonPk,proto3" json:"babylon_pk,omitempty"`
	// btc_pk is the Bitcoin secp256k1 PK of this BTC delegation
	// the PK follows encoding in BIP-340 spec
	BtcPk *github_com_babylonchain_babylon_types.BIP340PubKey `protobuf:"bytes,2,opt,name=btc_pk,json=btcPk,proto3,customtype=github.com/babylonchain/babylon/types.BIP340PubKey" json:"btc_pk,omitempty"`
	// pop is the proof of possession of babylon_pk and btc_pk
	Pop *ProofOfPossession `protobuf:"bytes,3,opt,name=pop,proto3" json:"pop,omitempty"`
	// val_btc_pk_list is the list of BIP-340 PKs of the BTC validators that
	// this BTC delegation delegates to
	// If there is more than 1 PKs, then this means the delegation is restaked
	// to multiple BTC validators
	ValBtcPkList []github_com_babylonchain_babylon_types.BIP340PubKey `protobuf:"bytes,4,rep,name=val_btc_pk_list,json=valBtcPkList,proto3,customtype=github.com/babylonchain/babylon/types.BIP340PubKey" json:"val_btc_pk_list,omitempty"`
	// start_height is the start BTC height of the BTC delegation
	// it is the start BTC height of the timelock
	StartHeight uint64 `protobuf:"varint,5,opt,name=start_height,json=startHeight,proto3" json:"start_height,omitempty"`
	// end_height is the end height of the BTC delegation
	// it is the end BTC height of the timelock - w
	EndHeight uint64 `protobuf:"varint,6,opt,name=end_height,json=endHeight,proto3" json:"end_height,omitempty"`
	// total_sat is the total amount of BTC stakes in this delegation
	// quantified in satoshi
	TotalSat uint64 `protobuf:"varint,7,opt,name=total_sat,json=totalSat,proto3" json:"total_sat,omitempty"`
	// staking_tx is the staking tx
	StakingTx []byte `protobuf:"bytes,8,opt,name=staking_tx,json=stakingTx,proto3" json:"staking_tx,omitempty"`
	// staking_output_idx is the index of the staking output in the staking tx
	StakingOutputIdx uint32 `protobuf:"varint,9,opt,name=staking_output_idx,json=stakingOutputIdx,proto3" json:"staking_output_idx,omitempty"`
	// slashing_tx is the slashing tx
	// It is partially signed by SK corresponding to btc_pk, but not signed by
	// validator or covenant yet.
	SlashingTx *BTCSlashingTx `protobuf:"bytes,10,opt,name=slashing_tx,json=slashingTx,proto3,customtype=BTCSlashingTx" json:"slashing_tx,omitempty"`
	// delegator_sig is the signature on the slashing tx
	// by the delegator (i.e., SK corresponding to btc_pk).
	// It will be a part of the witness for the staking tx output.
	DelegatorSig *github_com_babylonchain_babylon_types.BIP340Signature `protobuf:"bytes,11,opt,name=delegator_sig,json=delegatorSig,proto3,customtype=github.com/babylonchain/babylon/types.BIP340Signature" json:"delegator_sig,omitempty"`
	// covenant_sig is the signature signature on the slashing tx
	// by the covenant (i.e., SK corresponding to covenant_pk in params)
	// It will be a part of the witness for the staking tx output.
	// TODO: change to a set of (covenant PK, covenant adaptor signature) tuples
	CovenantSig *github_com_babylonchain_babylon_types.BIP340Signature `protobuf:"bytes,12,opt,name=covenant_sig,json=covenantSig,proto3,customtype=github.com/babylonchain/babylon/types.BIP340Signature" json:"covenant_sig,omitempty"`
	// if this object is present it menans that staker requested undelegation, and whole
	// delegation is being undelegated.
	// TODO: Consider whether it would be better to store it in separate store, and not
	// directly in delegation object
	BtcUndelegation *BTCUndelegation `protobuf:"bytes,13,opt,name=btc_undelegation,json=btcUndelegation,proto3" json:"btc_undelegation,omitempty"`
}

func (m *BTCDelegation) Reset()         { *m = BTCDelegation{} }
func (m *BTCDelegation) String() string { return proto.CompactTextString(m) }
func (*BTCDelegation) ProtoMessage()    {}
func (*BTCDelegation) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{2}
}
func (m *BTCDelegation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BTCDelegation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BTCDelegation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BTCDelegation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BTCDelegation.Merge(m, src)
}
func (m *BTCDelegation) XXX_Size() int {
	return m.Size()
}
func (m *BTCDelegation) XXX_DiscardUnknown() {
	xxx_messageInfo_BTCDelegation.DiscardUnknown(m)
}

var xxx_messageInfo_BTCDelegation proto.InternalMessageInfo

func (m *BTCDelegation) GetBabylonPk() *secp256k1.PubKey {
	if m != nil {
		return m.BabylonPk
	}
	return nil
}

func (m *BTCDelegation) GetPop() *ProofOfPossession {
	if m != nil {
		return m.Pop
	}
	return nil
}

func (m *BTCDelegation) GetStartHeight() uint64 {
	if m != nil {
		return m.StartHeight
	}
	return 0
}

func (m *BTCDelegation) GetEndHeight() uint64 {
	if m != nil {
		return m.EndHeight
	}
	return 0
}

func (m *BTCDelegation) GetTotalSat() uint64 {
	if m != nil {
		return m.TotalSat
	}
	return 0
}

func (m *BTCDelegation) GetStakingTx() []byte {
	if m != nil {
		return m.StakingTx
	}
	return nil
}

func (m *BTCDelegation) GetStakingOutputIdx() uint32 {
	if m != nil {
		return m.StakingOutputIdx
	}
	return 0
}

func (m *BTCDelegation) GetBtcUndelegation() *BTCUndelegation {
	if m != nil {
		return m.BtcUndelegation
	}
	return nil
}

// BTCUndelegation signalizes that the delegation is being undelegated
type BTCUndelegation struct {
	// unbonding_tx is the transaction which will transfer the funds from staking
	// output to unbonding output. Unbonding output will usually have lower timelock
	// than staking output.
	UnbondingTx []byte `protobuf:"bytes,1,opt,name=unbonding_tx,json=unbondingTx,proto3" json:"unbonding_tx,omitempty"`
	// unbonding_time describes how long the funds will be locked in the unbonding output
	UnbondingTime uint32 `protobuf:"varint,2,opt,name=unbonding_time,json=unbondingTime,proto3" json:"unbonding_time,omitempty"`
	// slashing_tx is the slashing tx for unbodning transactions
	// It is partially signed by SK corresponding to btc_pk, but not signed by
	// validator or covenant yet.
	SlashingTx *BTCSlashingTx `protobuf:"bytes,3,opt,name=slashing_tx,json=slashingTx,proto3,customtype=BTCSlashingTx" json:"slashing_tx,omitempty"`
	// delegator_slashing_sig is the signature on the slashing tx
	// by the delegator (i.e., SK corresponding to btc_pk).
	// It will be a part of the witness for the unbodning tx output.
	DelegatorSlashingSig *github_com_babylonchain_babylon_types.BIP340Signature `protobuf:"bytes,4,opt,name=delegator_slashing_sig,json=delegatorSlashingSig,proto3,customtype=github.com/babylonchain/babylon/types.BIP340Signature" json:"delegator_slashing_sig,omitempty"`
	// covenant_slashing_sig is the signature on the slashing tx
	// by the covenant (i.e., SK corresponding to covenant_pk in params)
	// It must be provided after processing undelagate message by Babylon
	// TODO: change to a set of (covenant PK, covenant adaptor signature) tuples
	CovenantSlashingSig *github_com_babylonchain_babylon_types.BIP340Signature `protobuf:"bytes,5,opt,name=covenant_slashing_sig,json=covenantSlashingSig,proto3,customtype=github.com/babylonchain/babylon/types.BIP340Signature" json:"covenant_slashing_sig,omitempty"`
	// covenant_unbonding_sig is the signature on the unbonding tx
	// by the covenant (i.e., SK corresponding to covenant_pk in params)
	// It must be provided after processing undelagate message by Babylon and after
	// validator sig will be provided by validator
	// TODO: change to a set of (covenant PK, covenant Schnorr signature) tuples
	CovenantUnbondingSig *github_com_babylonchain_babylon_types.BIP340Signature `protobuf:"bytes,6,opt,name=covenant_unbonding_sig,json=covenantUnbondingSig,proto3,customtype=github.com/babylonchain/babylon/types.BIP340Signature" json:"covenant_unbonding_sig,omitempty"`
}

func (m *BTCUndelegation) Reset()         { *m = BTCUndelegation{} }
func (m *BTCUndelegation) String() string { return proto.CompactTextString(m) }
func (*BTCUndelegation) ProtoMessage()    {}
func (*BTCUndelegation) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{3}
}
func (m *BTCUndelegation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BTCUndelegation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BTCUndelegation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BTCUndelegation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BTCUndelegation.Merge(m, src)
}
func (m *BTCUndelegation) XXX_Size() int {
	return m.Size()
}
func (m *BTCUndelegation) XXX_DiscardUnknown() {
	xxx_messageInfo_BTCUndelegation.DiscardUnknown(m)
}

var xxx_messageInfo_BTCUndelegation proto.InternalMessageInfo

func (m *BTCUndelegation) GetUnbondingTx() []byte {
	if m != nil {
		return m.UnbondingTx
	}
	return nil
}

func (m *BTCUndelegation) GetUnbondingTime() uint32 {
	if m != nil {
		return m.UnbondingTime
	}
	return 0
}

// BTCUndelegationInfo provides all necessary info about the undeleagation
type BTCUndelegationInfo struct {
	// unbonding_tx is the transaction which will transfer the funds from staking
	// output to unbonding output. Unbonding output will usually have lower timelock
	// than staking output.
	UnbondingTx []byte `protobuf:"bytes,1,opt,name=unbonding_tx,json=unbondingTx,proto3" json:"unbonding_tx,omitempty"`
	// covenant_unbonding_sig is the signature on the unbonding tx
	// by the covenant (i.e., SK corresponding to covenant_pk in params)
	// it will be nil if covenant didn't sign it yet
	// TODO: change to a set of (covenant PK, covenant Schnorr signature) tuples
	CovenantUnbondingSig *github_com_babylonchain_babylon_types.BIP340Signature `protobuf:"bytes,2,opt,name=covenant_unbonding_sig,json=covenantUnbondingSig,proto3,customtype=github.com/babylonchain/babylon/types.BIP340Signature" json:"covenant_unbonding_sig,omitempty"`
}

func (m *BTCUndelegationInfo) Reset()         { *m = BTCUndelegationInfo{} }
func (m *BTCUndelegationInfo) String() string { return proto.CompactTextString(m) }
func (*BTCUndelegationInfo) ProtoMessage()    {}
func (*BTCUndelegationInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{4}
}
func (m *BTCUndelegationInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BTCUndelegationInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BTCUndelegationInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BTCUndelegationInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BTCUndelegationInfo.Merge(m, src)
}
func (m *BTCUndelegationInfo) XXX_Size() int {
	return m.Size()
}
func (m *BTCUndelegationInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BTCUndelegationInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BTCUndelegationInfo proto.InternalMessageInfo

func (m *BTCUndelegationInfo) GetUnbondingTx() []byte {
	if m != nil {
		return m.UnbondingTx
	}
	return nil
}

// BTCDelegatorDelegations is a collection of BTC delegations from the same delegator.
type BTCDelegatorDelegations struct {
	Dels []*BTCDelegation `protobuf:"bytes,1,rep,name=dels,proto3" json:"dels,omitempty"`
}

func (m *BTCDelegatorDelegations) Reset()         { *m = BTCDelegatorDelegations{} }
func (m *BTCDelegatorDelegations) String() string { return proto.CompactTextString(m) }
func (*BTCDelegatorDelegations) ProtoMessage()    {}
func (*BTCDelegatorDelegations) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{5}
}
func (m *BTCDelegatorDelegations) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BTCDelegatorDelegations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BTCDelegatorDelegations.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BTCDelegatorDelegations) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BTCDelegatorDelegations.Merge(m, src)
}
func (m *BTCDelegatorDelegations) XXX_Size() int {
	return m.Size()
}
func (m *BTCDelegatorDelegations) XXX_DiscardUnknown() {
	xxx_messageInfo_BTCDelegatorDelegations.DiscardUnknown(m)
}

var xxx_messageInfo_BTCDelegatorDelegations proto.InternalMessageInfo

func (m *BTCDelegatorDelegations) GetDels() []*BTCDelegation {
	if m != nil {
		return m.Dels
	}
	return nil
}

// BTCDelegatorDelegationIndex is a list of staking tx hashes of BTC delegations from the same delegator.
type BTCDelegatorDelegationIndex struct {
	StakingTxHashList [][]byte `protobuf:"bytes,1,rep,name=staking_tx_hash_list,json=stakingTxHashList,proto3" json:"staking_tx_hash_list,omitempty"`
}

func (m *BTCDelegatorDelegationIndex) Reset()         { *m = BTCDelegatorDelegationIndex{} }
func (m *BTCDelegatorDelegationIndex) String() string { return proto.CompactTextString(m) }
func (*BTCDelegatorDelegationIndex) ProtoMessage()    {}
func (*BTCDelegatorDelegationIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{6}
}
func (m *BTCDelegatorDelegationIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BTCDelegatorDelegationIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BTCDelegatorDelegationIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BTCDelegatorDelegationIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BTCDelegatorDelegationIndex.Merge(m, src)
}
func (m *BTCDelegatorDelegationIndex) XXX_Size() int {
	return m.Size()
}
func (m *BTCDelegatorDelegationIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_BTCDelegatorDelegationIndex.DiscardUnknown(m)
}

var xxx_messageInfo_BTCDelegatorDelegationIndex proto.InternalMessageInfo

func (m *BTCDelegatorDelegationIndex) GetStakingTxHashList() [][]byte {
	if m != nil {
		return m.StakingTxHashList
	}
	return nil
}

// SignatureInfo is a BIP-340 signature together with its signer's BIP-340 PK
type SignatureInfo struct {
	Pk  *github_com_babylonchain_babylon_types.BIP340PubKey    `protobuf:"bytes,1,opt,name=pk,proto3,customtype=github.com/babylonchain/babylon/types.BIP340PubKey" json:"pk,omitempty"`
	Sig *github_com_babylonchain_babylon_types.BIP340Signature `protobuf:"bytes,2,opt,name=sig,proto3,customtype=github.com/babylonchain/babylon/types.BIP340Signature" json:"sig,omitempty"`
}

func (m *SignatureInfo) Reset()         { *m = SignatureInfo{} }
func (m *SignatureInfo) String() string { return proto.CompactTextString(m) }
func (*SignatureInfo) ProtoMessage()    {}
func (*SignatureInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{7}
}
func (m *SignatureInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignatureInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignatureInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignatureInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignatureInfo.Merge(m, src)
}
func (m *SignatureInfo) XXX_Size() int {
	return m.Size()
}
func (m *SignatureInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SignatureInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SignatureInfo proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("babylon.btcstaking.v1.BTCDelegationStatus", BTCDelegationStatus_name, BTCDelegationStatus_value)
	proto.RegisterType((*BTCValidator)(nil), "babylon.btcstaking.v1.BTCValidator")
	proto.RegisterType((*BTCValidatorWithMeta)(nil), "babylon.btcstaking.v1.BTCValidatorWithMeta")
	proto.RegisterType((*BTCDelegation)(nil), "babylon.btcstaking.v1.BTCDelegation")
	proto.RegisterType((*BTCUndelegation)(nil), "babylon.btcstaking.v1.BTCUndelegation")
	proto.RegisterType((*BTCUndelegationInfo)(nil), "babylon.btcstaking.v1.BTCUndelegationInfo")
	proto.RegisterType((*BTCDelegatorDelegations)(nil), "babylon.btcstaking.v1.BTCDelegatorDelegations")
	proto.RegisterType((*BTCDelegatorDelegationIndex)(nil), "babylon.btcstaking.v1.BTCDelegatorDelegationIndex")
	proto.RegisterType((*SignatureInfo)(nil), "babylon.btcstaking.v1.SignatureInfo")
}

func init() {
	proto.RegisterFile("babylon/btcstaking/v1/btcstaking.proto", fileDescriptor_3851ae95ccfaf7db)
}

var fileDescriptor_3851ae95ccfaf7db = []byte{
	// 1046 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0xce, 0xda, 0x8e, 0x5b, 0x1f, 0xdb, 0xc4, 0x9d, 0xa6, 0xc1, 0x24, 0xc2, 0x36, 0xa6, 0x54,
	0x16, 0xa2, 0x6b, 0x92, 0xfe, 0x08, 0xb8, 0x40, 0xaa, 0xe3, 0x40, 0xad, 0xe6, 0xc7, 0xac, 0x9d,
	0x22, 0x10, 0xb0, 0x9a, 0xdd, 0x9d, 0xac, 0x57, 0xb6, 0x77, 0x56, 0x9e, 0xb1, 0xb1, 0xef, 0x79,
	0x00, 0x1e, 0x82, 0x1b, 0xb8, 0xe6, 0x21, 0xb8, 0xac, 0xe0, 0x06, 0xe5, 0x22, 0xaa, 0x92, 0x17,
	0x41, 0x3b, 0x3b, 0xeb, 0xdd, 0x84, 0x04, 0x5a, 0x1c, 0xee, 0x3c, 0x73, 0xce, 0xf9, 0xce, 0x77,
	0xbe, 0xef, 0x64, 0xb2, 0x70, 0xcf, 0xc0, 0xc6, 0x6c, 0x40, 0xdd, 0xba, 0xc1, 0x4d, 0xc6, 0x71,
	0xdf, 0x71, 0xed, 0xfa, 0x64, 0x33, 0x76, 0x52, 0xbd, 0x11, 0xe5, 0x14, 0xdd, 0x91, 0x79, 0x6a,
	0x2c, 0x32, 0xd9, 0x5c, 0x5f, 0xb5, 0xa9, 0x4d, 0x45, 0x46, 0xdd, 0xff, 0x15, 0x24, 0xaf, 0xbf,
	0x65, 0x52, 0x36, 0xa4, 0x4c, 0x0f, 0x02, 0xc1, 0x41, 0x86, 0xaa, 0xc1, 0xa9, 0x6e, 0x8e, 0x66,
	0x1e, 0xa7, 0x75, 0x46, 0x4c, 0x6f, 0xeb, 0xd1, 0xe3, 0xfe, 0x66, 0xbd, 0x4f, 0x66, 0x61, 0xce,
	0x5d, 0x99, 0x13, 0xf1, 0x31, 0x08, 0xc7, 0x9b, 0xf5, 0x73, 0x8c, 0xd6, 0xcb, 0x97, 0x33, 0xf7,
	0xa8, 0x17, 0x24, 0x54, 0xff, 0x48, 0x42, 0xae, 0xd1, 0xdd, 0x7e, 0x8e, 0x07, 0x8e, 0x85, 0x39,
	0x1d, 0xa1, 0x1d, 0xc8, 0x5a, 0x84, 0x99, 0x23, 0xc7, 0xe3, 0x0e, 0x75, 0x8b, 0x4a, 0x45, 0xa9,
	0x65, 0xb7, 0xde, 0x55, 0x25, 0xbf, 0x68, 0x2a, 0xd1, 0x4d, 0x6d, 0x46, 0xa9, 0x5a, 0xbc, 0x0e,
	0xed, 0x01, 0x98, 0x74, 0x38, 0x74, 0x18, 0xf3, 0x51, 0x12, 0x15, 0xa5, 0x96, 0x69, 0xdc, 0x3f,
	0x3e, 0x29, 0x6f, 0x04, 0x40, 0xcc, 0xea, 0xab, 0x0e, 0xad, 0x0f, 0x31, 0xef, 0xa9, 0xbb, 0xc4,
	0xc6, 0xe6, 0xac, 0x49, 0xcc, 0xdf, 0x7f, 0xbd, 0x0f, 0xb2, 0x4f, 0x93, 0x98, 0x5a, 0x0c, 0x00,
	0x7d, 0x0a, 0x20, 0x27, 0xd1, 0xbd, 0x7e, 0x31, 0x29, 0x48, 0x95, 0x43, 0x52, 0x81, 0x4c, 0xea,
	0x5c, 0x26, 0xb5, 0x3d, 0x36, 0x9e, 0x91, 0x99, 0x96, 0x91, 0x25, 0xed, 0x3e, 0xda, 0x83, 0xb4,
	0xc1, 0x4d, 0xbf, 0x36, 0x55, 0x51, 0x6a, 0xb9, 0xc6, 0xe3, 0xe3, 0x93, 0xf2, 0x96, 0xed, 0xf0,
	0xde, 0xd8, 0x50, 0x4d, 0x3a, 0xac, 0xcb, 0x4c, 0xb3, 0x87, 0x1d, 0x37, 0x3c, 0xd4, 0xf9, 0xcc,
	0x23, 0x4c, 0x6d, 0xb4, 0xda, 0x0f, 0x1e, 0x7e, 0x28, 0x21, 0x97, 0x0d, 0x6e, 0xb6, 0xfb, 0xe8,
	0x13, 0x48, 0x7a, 0xd4, 0x2b, 0x2e, 0x0b, 0x1e, 0x35, 0xf5, 0x52, 0xdb, 0xd5, 0xf6, 0x88, 0xd2,
	0xa3, 0x83, 0xa3, 0x36, 0x65, 0x8c, 0x88, 0x29, 0x34, 0xbf, 0x08, 0x3d, 0x84, 0x35, 0x36, 0xc0,
	0xac, 0x47, 0x2c, 0x3d, 0x1c, 0xa9, 0x47, 0x1c, 0xbb, 0xc7, 0x8b, 0xe9, 0x8a, 0x52, 0x4b, 0x69,
	0xab, 0x32, 0xda, 0x08, 0x82, 0x4f, 0x45, 0x0c, 0x7d, 0x00, 0x68, 0x5e, 0xc5, 0xcd, 0xb0, 0xe2,
	0x86, 0xa8, 0x28, 0x84, 0x15, 0xdc, 0x0c, 0xb2, 0xab, 0x3f, 0x24, 0x60, 0x35, 0xee, 0xea, 0x97,
	0x0e, 0xef, 0xed, 0x11, 0x8e, 0x63, 0x3a, 0x28, 0xd7, 0xa1, 0xc3, 0x1a, 0xa4, 0x25, 0x93, 0x84,
	0x60, 0x22, 0x4f, 0xe8, 0x1d, 0xc8, 0x4d, 0x28, 0x77, 0x5c, 0x5b, 0xf7, 0xe8, 0xf7, 0x64, 0x24,
	0x0c, 0x4b, 0x69, 0xd9, 0xe0, 0xae, 0xed, 0x5f, 0xfd, 0x83, 0x0c, 0xa9, 0xd7, 0x96, 0x61, 0xf9,
	0x0a, 0x19, 0x7e, 0x49, 0x43, 0xbe, 0xd1, 0xdd, 0x6e, 0x92, 0x01, 0xb1, 0x31, 0xff, 0xfb, 0x1e,
	0x29, 0x0b, 0xec, 0x51, 0xe2, 0x1a, 0xf7, 0x28, 0xf9, 0x5f, 0xf6, 0xe8, 0x5b, 0x58, 0x99, 0xe0,
	0x81, 0x1e, 0xd0, 0xd1, 0x07, 0x0e, 0xf3, 0x95, 0x4b, 0x2e, 0xc0, 0x29, 0x37, 0xc1, 0x83, 0x86,
	0x4f, 0x6b, 0xd7, 0x61, 0xc2, 0x42, 0xc6, 0xf1, 0x88, 0x9f, 0xd7, 0x38, 0x2b, 0xee, 0xa4, 0x19,
	0x6f, 0x03, 0x10, 0xd7, 0x3a, 0xbf, 0xbd, 0x19, 0xe2, 0x5a, 0x32, 0xbc, 0x01, 0x19, 0x4e, 0x39,
	0x1e, 0xe8, 0x0c, 0x87, 0x9b, 0x7a, 0x53, 0x5c, 0x74, 0xb0, 0xa8, 0x95, 0x23, 0xea, 0x7c, 0x5a,
	0xbc, 0xe9, 0x8b, 0xa9, 0x65, 0xe4, 0x4d, 0x77, 0x2a, 0x7c, 0x96, 0x61, 0x3a, 0xe6, 0xde, 0x98,
	0xeb, 0x8e, 0x35, 0x2d, 0x66, 0x2a, 0x4a, 0x2d, 0xaf, 0x15, 0x64, 0xe4, 0x40, 0x04, 0x5a, 0xd6,
	0x14, 0x6d, 0x41, 0x56, 0x78, 0x2f, 0xd1, 0x40, 0x58, 0x73, 0xeb, 0xf8, 0xa4, 0xec, 0xbb, 0xdf,
	0x91, 0x91, 0xee, 0x54, 0x03, 0x36, 0xff, 0x8d, 0xbe, 0x83, 0xbc, 0x15, 0xec, 0x05, 0x1d, 0xe9,
	0xcc, 0xb1, 0x8b, 0x59, 0x51, 0xf5, 0xf1, 0xf1, 0x49, 0xf9, 0xd1, 0xeb, 0x88, 0xd7, 0x71, 0x6c,
	0x17, 0xf3, 0xf1, 0x88, 0x68, 0xb9, 0x39, 0x5e, 0xc7, 0xb1, 0xd1, 0x37, 0x90, 0x33, 0xe9, 0x84,
	0xb8, 0xd8, 0xe5, 0x02, 0x3e, 0xb7, 0x28, 0x7c, 0x36, 0x84, 0xf3, 0xd1, 0xbf, 0x80, 0x82, 0x6f,
	0xfc, 0xd8, 0xb5, 0xe6, 0xbb, 0x5d, 0xcc, 0x8b, 0x2d, 0xba, 0x77, 0xc5, 0x16, 0x35, 0xba, 0xdb,
	0x87, 0xb1, 0x6c, 0x6d, 0xc5, 0xe0, 0x66, 0xfc, 0xa2, 0xfa, 0x32, 0x09, 0x2b, 0x17, 0x92, 0xfc,
	0x25, 0x18, 0xbb, 0x06, 0x75, 0x2d, 0xa9, 0xac, 0x78, 0x34, 0xb4, 0xec, 0xfc, 0xae, 0x3b, 0x45,
	0xef, 0xc1, 0x1b, 0xb1, 0x14, 0x67, 0x48, 0xc4, 0x5f, 0x46, 0x5e, 0xcb, 0x47, 0x49, 0xce, 0x90,
	0x5c, 0xb4, 0x28, 0xf9, 0x2a, 0x16, 0x51, 0x58, 0x8b, 0x59, 0x14, 0x56, 0xfb, 0x62, 0xa6, 0x16,
	0x15, 0x73, 0x35, 0xf2, 0x4a, 0xe2, 0xfa, 0xaa, 0x0e, 0xe1, 0x4e, 0xe4, 0x59, 0xbc, 0xdf, 0xf2,
	0xa2, 0xfd, 0x6e, 0xcf, 0xcd, 0x8b, 0xb5, 0xa3, 0xb0, 0x36, 0x6f, 0x17, 0x69, 0xe8, 0xf7, 0x4b,
	0x2f, 0x3c, 0x5f, 0x08, 0x7c, 0x18, 0xe2, 0x76, 0x1c, 0xbb, 0xfa, 0xb3, 0x02, 0xb7, 0x2f, 0x58,
	0xdc, 0x72, 0x8f, 0xe8, 0xab, 0xd8, 0x7c, 0x35, 0xd7, 0xc4, 0xff, 0xc3, 0xb5, 0x03, 0x6f, 0x46,
	0x4f, 0x37, 0x1d, 0x45, 0x6f, 0x38, 0x43, 0x1f, 0x41, 0xca, 0x22, 0x03, 0x56, 0x54, 0x2a, 0xc9,
	0x5a, 0x76, 0xeb, 0xee, 0xd5, 0x0b, 0x1f, 0x15, 0x69, 0xa2, 0xa2, 0xba, 0x0f, 0x1b, 0x97, 0x83,
	0xb6, 0x5c, 0x8b, 0x4c, 0x51, 0x1d, 0x56, 0xa3, 0x47, 0x49, 0xef, 0x61, 0xd6, 0x0b, 0xde, 0x55,
	0xbf, 0x51, 0x4e, 0xbb, 0x35, 0x7f, 0x9e, 0x9e, 0x62, 0xd6, 0xf3, 0x1f, 0xc9, 0xea, 0x4f, 0x0a,
	0xe4, 0xe7, 0x83, 0x08, 0x29, 0x3f, 0x83, 0xc4, 0xc2, 0xff, 0x5c, 0x13, 0x5e, 0x1f, 0x3d, 0x83,
	0xe4, 0xb5, 0x88, 0xeb, 0xa3, 0xbc, 0xdf, 0x15, 0xb6, 0x47, 0xd3, 0x76, 0x38, 0xe6, 0x63, 0x86,
	0xb2, 0x70, 0xa3, 0xbd, 0xb3, 0xdf, 0x6c, 0xed, 0x7f, 0x5e, 0x58, 0x42, 0x00, 0xe9, 0x27, 0xdb,
	0xdd, 0xd6, 0xf3, 0x9d, 0x82, 0x82, 0xf2, 0x90, 0x39, 0xdc, 0x6f, 0x1c, 0x04, 0xa1, 0x04, 0xca,
	0xc1, 0xcd, 0xe0, 0xb8, 0xd3, 0x2c, 0x24, 0xd1, 0x0d, 0x48, 0x3e, 0xd9, 0xff, 0xaa, 0x90, 0x6a,
	0xec, 0xfe, 0x76, 0x5a, 0x52, 0x5e, 0x9c, 0x96, 0x94, 0x97, 0xa7, 0x25, 0xe5, 0xc7, 0xb3, 0xd2,
	0xd2, 0x8b, 0xb3, 0xd2, 0xd2, 0x9f, 0x67, 0xa5, 0xa5, 0xaf, 0xff, 0x75, 0xe8, 0x69, 0xfc, 0x7b,
	0x54, 0x10, 0x37, 0xd2, 0xe2, 0x7b, 0xf4, 0xc1, 0x5f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xf9, 0x12,
	0x09, 0xab, 0x6c, 0x0b, 0x00, 0x00,
}

func (m *BTCValidator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BTCValidator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCValidator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SlashedBtcHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.SlashedBtcHeight))
		i--
		dAtA[i] = 0x38
	}
	if m.SlashedBabylonHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.SlashedBabylonHeight))
		i--
		dAtA[i] = 0x30
	}
	if m.Pop != nil {
		{
			size, err := m.Pop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.BtcPk != nil {
		{
			size := m.BtcPk.Size()
			i -= size
			if _, err := m.BtcPk.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.BabylonPk != nil {
		{
			size, err := m.BabylonPk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Commission != nil {
		{
			size := m.Commission.Size()
			i -= size
			if _, err := m.Commission.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Description != nil {
		{
			size, err := m.Description.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BTCValidatorWithMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BTCValidatorWithMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCValidatorWithMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SlashedBtcHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.SlashedBtcHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.SlashedBabylonHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.SlashedBabylonHeight))
		i--
		dAtA[i] = 0x20
	}
	if m.VotingPower != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.VotingPower))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.BtcPk != nil {
		{
			size := m.BtcPk.Size()
			i -= size
			if _, err := m.BtcPk.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BTCDelegation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BTCDelegation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCDelegation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BtcUndelegation != nil {
		{
			size, err := m.BtcUndelegation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.CovenantSig != nil {
		{
			size := m.CovenantSig.Size()
			i -= size
			if _, err := m.CovenantSig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.DelegatorSig != nil {
		{
			size := m.DelegatorSig.Size()
			i -= size
			if _, err := m.DelegatorSig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.SlashingTx != nil {
		{
			size := m.SlashingTx.Size()
			i -= size
			if _, err := m.SlashingTx.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.StakingOutputIdx != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.StakingOutputIdx))
		i--
		dAtA[i] = 0x48
	}
	if len(m.StakingTx) > 0 {
		i -= len(m.StakingTx)
		copy(dAtA[i:], m.StakingTx)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.StakingTx)))
		i--
		dAtA[i] = 0x42
	}
	if m.TotalSat != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.TotalSat))
		i--
		dAtA[i] = 0x38
	}
	if m.EndHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.EndHeight))
		i--
		dAtA[i] = 0x30
	}
	if m.StartHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.StartHeight))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ValBtcPkList) > 0 {
		for iNdEx := len(m.ValBtcPkList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size := m.ValBtcPkList[iNdEx].Size()
				i -= size
				if _, err := m.ValBtcPkList[iNdEx].MarshalTo(dAtA[i:]); err != nil {
					return 0, err
				}
				i = encodeVarintBtcstaking(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Pop != nil {
		{
			size, err := m.Pop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.BtcPk != nil {
		{
			size := m.BtcPk.Size()
			i -= size
			if _, err := m.BtcPk.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BabylonPk != nil {
		{
			size, err := m.BabylonPk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BTCUndelegation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BTCUndelegation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCUndelegation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CovenantUnbondingSig != nil {
		{
			size := m.CovenantUnbondingSig.Size()
			i -= size
			if _, err := m.CovenantUnbondingSig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.CovenantSlashingSig != nil {
		{
			size := m.CovenantSlashingSig.Size()
			i -= size
			if _, err := m.CovenantSlashingSig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DelegatorSlashingSig != nil {
		{
			size := m.DelegatorSlashingSig.Size()
			i -= size
			if _, err := m.DelegatorSlashingSig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.SlashingTx != nil {
		{
			size := m.SlashingTx.Size()
			i -= size
			if _, err := m.SlashingTx.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.UnbondingTime != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.UnbondingTime))
		i--
		dAtA[i] = 0x10
	}
	if len(m.UnbondingTx) > 0 {
		i -= len(m.UnbondingTx)
		copy(dAtA[i:], m.UnbondingTx)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.UnbondingTx)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BTCUndelegationInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BTCUndelegationInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCUndelegationInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CovenantUnbondingSig != nil {
		{
			size := m.CovenantUnbondingSig.Size()
			i -= size
			if _, err := m.CovenantUnbondingSig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.UnbondingTx) > 0 {
		i -= len(m.UnbondingTx)
		copy(dAtA[i:], m.UnbondingTx)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.UnbondingTx)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BTCDelegatorDelegations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BTCDelegatorDelegations) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCDelegatorDelegations) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Dels) > 0 {
		for iNdEx := len(m.Dels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Dels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBtcstaking(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BTCDelegatorDelegationIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BTCDelegatorDelegationIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCDelegatorDelegationIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StakingTxHashList) > 0 {
		for iNdEx := len(m.StakingTxHashList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.StakingTxHashList[iNdEx])
			copy(dAtA[i:], m.StakingTxHashList[iNdEx])
			i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.StakingTxHashList[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SignatureInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignatureInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignatureInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sig != nil {
		{
			size := m.Sig.Size()
			i -= size
			if _, err := m.Sig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Pk != nil {
		{
			size := m.Pk.Size()
			i -= size
			if _, err := m.Pk.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintBtcstaking(dAtA []byte, offset int, v uint64) int {
	offset -= sovBtcstaking(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BTCValidator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Description != nil {
		l = m.Description.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.Commission != nil {
		l = m.Commission.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.BabylonPk != nil {
		l = m.BabylonPk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.BtcPk != nil {
		l = m.BtcPk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.Pop != nil {
		l = m.Pop.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.SlashedBabylonHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.SlashedBabylonHeight))
	}
	if m.SlashedBtcHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.SlashedBtcHeight))
	}
	return n
}

func (m *BTCValidatorWithMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BtcPk != nil {
		l = m.BtcPk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovBtcstaking(uint64(m.Height))
	}
	if m.VotingPower != 0 {
		n += 1 + sovBtcstaking(uint64(m.VotingPower))
	}
	if m.SlashedBabylonHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.SlashedBabylonHeight))
	}
	if m.SlashedBtcHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.SlashedBtcHeight))
	}
	return n
}

func (m *BTCDelegation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BabylonPk != nil {
		l = m.BabylonPk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.BtcPk != nil {
		l = m.BtcPk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.Pop != nil {
		l = m.Pop.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if len(m.ValBtcPkList) > 0 {
		for _, e := range m.ValBtcPkList {
			l = e.Size()
			n += 1 + l + sovBtcstaking(uint64(l))
		}
	}
	if m.StartHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.StartHeight))
	}
	if m.EndHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.EndHeight))
	}
	if m.TotalSat != 0 {
		n += 1 + sovBtcstaking(uint64(m.TotalSat))
	}
	l = len(m.StakingTx)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.StakingOutputIdx != 0 {
		n += 1 + sovBtcstaking(uint64(m.StakingOutputIdx))
	}
	if m.SlashingTx != nil {
		l = m.SlashingTx.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.DelegatorSig != nil {
		l = m.DelegatorSig.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.CovenantSig != nil {
		l = m.CovenantSig.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.BtcUndelegation != nil {
		l = m.BtcUndelegation.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func (m *BTCUndelegation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UnbondingTx)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.UnbondingTime != 0 {
		n += 1 + sovBtcstaking(uint64(m.UnbondingTime))
	}
	if m.SlashingTx != nil {
		l = m.SlashingTx.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.DelegatorSlashingSig != nil {
		l = m.DelegatorSlashingSig.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.CovenantSlashingSig != nil {
		l = m.CovenantSlashingSig.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.CovenantUnbondingSig != nil {
		l = m.CovenantUnbondingSig.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func (m *BTCUndelegationInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UnbondingTx)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.CovenantUnbondingSig != nil {
		l = m.CovenantUnbondingSig.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func (m *BTCDelegatorDelegations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Dels) > 0 {
		for _, e := range m.Dels {
			l = e.Size()
			n += 1 + l + sovBtcstaking(uint64(l))
		}
	}
	return n
}

func (m *BTCDelegatorDelegationIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StakingTxHashList) > 0 {
		for _, b := range m.StakingTxHashList {
			l = len(b)
			n += 1 + l + sovBtcstaking(uint64(l))
		}
	}
	return n
}

func (m *SignatureInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pk != nil {
		l = m.Pk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.Sig != nil {
		l = m.Sig.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func sovBtcstaking(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBtcstaking(x uint64) (n int) {
	return sovBtcstaking(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BTCValidator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BTCValidator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BTCValidator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Description == nil {
				m.Description = &types.Description{}
			}
			if err := m.Description.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v cosmossdk_io_math.LegacyDec
			m.Commission = &v
			if err := m.Commission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BabylonPk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BabylonPk == nil {
				m.BabylonPk = &secp256k1.PubKey{}
			}
			if err := m.BabylonPk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcPk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340PubKey
			m.BtcPk = &v
			if err := m.BtcPk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pop == nil {
				m.Pop = &ProofOfPossession{}
			}
			if err := m.Pop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashedBabylonHeight", wireType)
			}
			m.SlashedBabylonHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashedBabylonHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashedBtcHeight", wireType)
			}
			m.SlashedBtcHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashedBtcHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BTCValidatorWithMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BTCValidatorWithMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BTCValidatorWithMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcPk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340PubKey
			m.BtcPk = &v
			if err := m.BtcPk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingPower", wireType)
			}
			m.VotingPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VotingPower |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashedBabylonHeight", wireType)
			}
			m.SlashedBabylonHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashedBabylonHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashedBtcHeight", wireType)
			}
			m.SlashedBtcHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashedBtcHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BTCDelegation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BTCDelegation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BTCDelegation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BabylonPk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BabylonPk == nil {
				m.BabylonPk = &secp256k1.PubKey{}
			}
			if err := m.BabylonPk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcPk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340PubKey
			m.BtcPk = &v
			if err := m.BtcPk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pop == nil {
				m.Pop = &ProofOfPossession{}
			}
			if err := m.Pop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValBtcPkList", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340PubKey
			m.ValBtcPkList = append(m.ValBtcPkList, v)
			if err := m.ValBtcPkList[len(m.ValBtcPkList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartHeight", wireType)
			}
			m.StartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndHeight", wireType)
			}
			m.EndHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSat", wireType)
			}
			m.TotalSat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSat |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakingTx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakingTx = append(m.StakingTx[:0], dAtA[iNdEx:postIndex]...)
			if m.StakingTx == nil {
				m.StakingTx = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakingOutputIdx", wireType)
			}
			m.StakingOutputIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StakingOutputIdx |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashingTx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v BTCSlashingTx
			m.SlashingTx = &v
			if err := m.SlashingTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340Signature
			m.DelegatorSig = &v
			if err := m.DelegatorSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CovenantSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340Signature
			m.CovenantSig = &v
			if err := m.CovenantSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcUndelegation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BtcUndelegation == nil {
				m.BtcUndelegation = &BTCUndelegation{}
			}
			if err := m.BtcUndelegation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BTCUndelegation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BTCUndelegation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BTCUndelegation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingTx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnbondingTx = append(m.UnbondingTx[:0], dAtA[iNdEx:postIndex]...)
			if m.UnbondingTx == nil {
				m.UnbondingTx = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingTime", wireType)
			}
			m.UnbondingTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnbondingTime |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashingTx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v BTCSlashingTx
			m.SlashingTx = &v
			if err := m.SlashingTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorSlashingSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340Signature
			m.DelegatorSlashingSig = &v
			if err := m.DelegatorSlashingSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CovenantSlashingSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340Signature
			m.CovenantSlashingSig = &v
			if err := m.CovenantSlashingSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CovenantUnbondingSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340Signature
			m.CovenantUnbondingSig = &v
			if err := m.CovenantUnbondingSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BTCUndelegationInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BTCUndelegationInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BTCUndelegationInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingTx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnbondingTx = append(m.UnbondingTx[:0], dAtA[iNdEx:postIndex]...)
			if m.UnbondingTx == nil {
				m.UnbondingTx = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CovenantUnbondingSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340Signature
			m.CovenantUnbondingSig = &v
			if err := m.CovenantUnbondingSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BTCDelegatorDelegations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BTCDelegatorDelegations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BTCDelegatorDelegations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dels = append(m.Dels, &BTCDelegation{})
			if err := m.Dels[len(m.Dels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BTCDelegatorDelegationIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BTCDelegatorDelegationIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BTCDelegatorDelegationIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakingTxHashList", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakingTxHashList = append(m.StakingTxHashList, make([]byte, postIndex-iNdEx))
			copy(m.StakingTxHashList[len(m.StakingTxHashList)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignatureInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignatureInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignatureInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340PubKey
			m.Pk = &v
			if err := m.Pk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340Signature
			m.Sig = &v
			if err := m.Sig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBtcstaking(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBtcstaking
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBtcstaking
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBtcstaking
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBtcstaking        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBtcstaking          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBtcstaking = fmt.Errorf("proto: unexpected end of group")
)
