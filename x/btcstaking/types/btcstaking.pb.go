// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: babylon/btcstaking/v1/btcstaking.proto

package types

import (
	fmt "fmt"
	github_com_babylonchain_babylon_types "github.com/babylonchain/babylon/types"
	_ "github.com/cosmos/cosmos-proto"
	secp256k1 "github.com/cosmos/cosmos-sdk/crypto/keys/secp256k1"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/x/staking/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// BTCDelegationStatus is the status of a delegation. There are two possible state
// transition paths:
// 1. PENDING -> ACTIVE -> UNBONDED - this is the typical path when timelock of staking
// transaction expires.
// 2. PENDING _> ACTIVE -> UNBONDING -> UNBONDED - this is the path when staker requests undelegation through
// MsgBTCUndelegate message.
type BTCDelegationStatus int32

const (
	// PENDING defines a delegation that is waiting for a jury signature to become active.
	BTCDelegationStatus_PENDING BTCDelegationStatus = 0
	// ACTIVE defines a delegation that has voting power
	BTCDelegationStatus_ACTIVE BTCDelegationStatus = 1
	// UNBONDING defines a delegation that is being unbonded i.e it received an unbonding tx
	// from staker, but not yet received signatures from validator and jury.
	// Delegation in this state already lost its voting power.
	BTCDelegationStatus_UNBONDING BTCDelegationStatus = 2
	// UNBONDED defines a delegation no longer has voting power:
	// - either reaching the end of staking transaction timelock
	// - or receiving unbonding tx and then receiving signatures from validator and jury for this
	// unbonding tx.
	BTCDelegationStatus_UNBONDED BTCDelegationStatus = 3
)

var BTCDelegationStatus_name = map[int32]string{
	0: "PENDING",
	1: "ACTIVE",
	2: "UNBONDING",
	3: "UNBONDED",
}

var BTCDelegationStatus_value = map[string]int32{
	"PENDING":   0,
	"ACTIVE":    1,
	"UNBONDING": 2,
	"UNBONDED":  3,
}

func (x BTCDelegationStatus) String() string {
	return proto.EnumName(BTCDelegationStatus_name, int32(x))
}

func (BTCDelegationStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{0}
}

// BTCValidator defines a BTC validator
type BTCValidator struct {
	// description defines the description terms for the BTC validator.
	Description *types.Description `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	// commission defines the commission rate of BTC validator.
	Commission *github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=commission,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"commission,omitempty"`
	// babylon_pk is the Babylon secp256k1 PK of this BTC validator
	BabylonPk *secp256k1.PubKey `protobuf:"bytes,3,opt,name=babylon_pk,json=babylonPk,proto3" json:"babylon_pk,omitempty"`
	// btc_pk is the Bitcoin secp256k1 PK of this BTC validator
	// the PK follows encoding in BIP-340 spec
	BtcPk *github_com_babylonchain_babylon_types.BIP340PubKey `protobuf:"bytes,4,opt,name=btc_pk,json=btcPk,proto3,customtype=github.com/babylonchain/babylon/types.BIP340PubKey" json:"btc_pk,omitempty"`
	// pop is the proof of possession of babylon_pk and btc_pk
	Pop *ProofOfPossession `protobuf:"bytes,5,opt,name=pop,proto3" json:"pop,omitempty"`
	// slashed_babylon_height indicates the Babylon height when
	// the BTC validator is slashed.
	// if it's 0 then the BTC validator is not slashed
	SlashedBabylonHeight uint64 `protobuf:"varint,6,opt,name=slashed_babylon_height,json=slashedBabylonHeight,proto3" json:"slashed_babylon_height,omitempty"`
	// slashed_btc_height indicates the BTC height when
	// the BTC validator is slashed.
	// if it's 0 then the BTC validator is not slashed
	SlashedBtcHeight uint64 `protobuf:"varint,7,opt,name=slashed_btc_height,json=slashedBtcHeight,proto3" json:"slashed_btc_height,omitempty"`
}

func (m *BTCValidator) Reset()         { *m = BTCValidator{} }
func (m *BTCValidator) String() string { return proto.CompactTextString(m) }
func (*BTCValidator) ProtoMessage()    {}
func (*BTCValidator) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{0}
}
func (m *BTCValidator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BTCValidator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BTCValidator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BTCValidator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BTCValidator.Merge(m, src)
}
func (m *BTCValidator) XXX_Size() int {
	return m.Size()
}
func (m *BTCValidator) XXX_DiscardUnknown() {
	xxx_messageInfo_BTCValidator.DiscardUnknown(m)
}

var xxx_messageInfo_BTCValidator proto.InternalMessageInfo

func (m *BTCValidator) GetDescription() *types.Description {
	if m != nil {
		return m.Description
	}
	return nil
}

func (m *BTCValidator) GetBabylonPk() *secp256k1.PubKey {
	if m != nil {
		return m.BabylonPk
	}
	return nil
}

func (m *BTCValidator) GetPop() *ProofOfPossession {
	if m != nil {
		return m.Pop
	}
	return nil
}

func (m *BTCValidator) GetSlashedBabylonHeight() uint64 {
	if m != nil {
		return m.SlashedBabylonHeight
	}
	return 0
}

func (m *BTCValidator) GetSlashedBtcHeight() uint64 {
	if m != nil {
		return m.SlashedBtcHeight
	}
	return 0
}

// BTCValidatorWithMeta wraps the BTCValidator with meta data.
type BTCValidatorWithMeta struct {
	// btc_pk is the Bitcoin secp256k1 PK of this BTC validator
	// the PK follows encoding in BIP-340 spec
	BtcPk *github_com_babylonchain_babylon_types.BIP340PubKey `protobuf:"bytes,1,opt,name=btc_pk,json=btcPk,proto3,customtype=github.com/babylonchain/babylon/types.BIP340PubKey" json:"btc_pk,omitempty"`
	// height is the queried Babylon height
	Height uint64 `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	// voting_power is the voting power of this BTC validator at the given height
	VotingPower uint64 `protobuf:"varint,3,opt,name=voting_power,json=votingPower,proto3" json:"voting_power,omitempty"`
	// slashed_babylon_height indicates the Babylon height when
	// the BTC validator is slashed.
	// if it's 0 then the BTC validator is not slashed
	SlashedBabylonHeight uint64 `protobuf:"varint,4,opt,name=slashed_babylon_height,json=slashedBabylonHeight,proto3" json:"slashed_babylon_height,omitempty"`
	// slashed_btc_height indicates the BTC height when
	// the BTC validator is slashed.
	// if it's 0 then the BTC validator is not slashed
	SlashedBtcHeight uint64 `protobuf:"varint,5,opt,name=slashed_btc_height,json=slashedBtcHeight,proto3" json:"slashed_btc_height,omitempty"`
}

func (m *BTCValidatorWithMeta) Reset()         { *m = BTCValidatorWithMeta{} }
func (m *BTCValidatorWithMeta) String() string { return proto.CompactTextString(m) }
func (*BTCValidatorWithMeta) ProtoMessage()    {}
func (*BTCValidatorWithMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{1}
}
func (m *BTCValidatorWithMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BTCValidatorWithMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BTCValidatorWithMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BTCValidatorWithMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BTCValidatorWithMeta.Merge(m, src)
}
func (m *BTCValidatorWithMeta) XXX_Size() int {
	return m.Size()
}
func (m *BTCValidatorWithMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_BTCValidatorWithMeta.DiscardUnknown(m)
}

var xxx_messageInfo_BTCValidatorWithMeta proto.InternalMessageInfo

func (m *BTCValidatorWithMeta) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *BTCValidatorWithMeta) GetVotingPower() uint64 {
	if m != nil {
		return m.VotingPower
	}
	return 0
}

func (m *BTCValidatorWithMeta) GetSlashedBabylonHeight() uint64 {
	if m != nil {
		return m.SlashedBabylonHeight
	}
	return 0
}

func (m *BTCValidatorWithMeta) GetSlashedBtcHeight() uint64 {
	if m != nil {
		return m.SlashedBtcHeight
	}
	return 0
}

// BTCDelegation defines a BTC delegation
type BTCDelegation struct {
	// babylon_pk is the Babylon secp256k1 PK of this BTC delegation
	BabylonPk *secp256k1.PubKey `protobuf:"bytes,1,opt,name=babylon_pk,json=babylonPk,proto3" json:"babylon_pk,omitempty"`
	// btc_pk is the Bitcoin secp256k1 PK of this BTC delegation
	// the PK follows encoding in BIP-340 spec
	BtcPk *github_com_babylonchain_babylon_types.BIP340PubKey `protobuf:"bytes,2,opt,name=btc_pk,json=btcPk,proto3,customtype=github.com/babylonchain/babylon/types.BIP340PubKey" json:"btc_pk,omitempty"`
	// pop is the proof of possession of babylon_pk and btc_pk
	Pop *ProofOfPossession `protobuf:"bytes,3,opt,name=pop,proto3" json:"pop,omitempty"`
	// val_btc_pk is the Bitcoin secp256k1 PK of the BTC validator that
	// this BTC delegation delegates to
	// the PK follows encoding in BIP-340 spec
	ValBtcPk *github_com_babylonchain_babylon_types.BIP340PubKey `protobuf:"bytes,4,opt,name=val_btc_pk,json=valBtcPk,proto3,customtype=github.com/babylonchain/babylon/types.BIP340PubKey" json:"val_btc_pk,omitempty"`
	// start_height is the start BTC height of the BTC delegation
	// it is the start BTC height of the timelock
	StartHeight uint64 `protobuf:"varint,5,opt,name=start_height,json=startHeight,proto3" json:"start_height,omitempty"`
	// end_height is the end height of the BTC delegation
	// it is the end BTC height of the timelock - w
	EndHeight uint64 `protobuf:"varint,6,opt,name=end_height,json=endHeight,proto3" json:"end_height,omitempty"`
	// total_sat is the total amount of BTC stakes in this delegation
	// quantified in satoshi
	TotalSat uint64 `protobuf:"varint,7,opt,name=total_sat,json=totalSat,proto3" json:"total_sat,omitempty"`
	// staking_tx is the staking tx
	StakingTx *BabylonBTCTaprootTx `protobuf:"bytes,8,opt,name=staking_tx,json=stakingTx,proto3" json:"staking_tx,omitempty"`
	// slashing_tx is the slashing tx
	// It is partially signed by SK corresponding to btc_pk, but not signed by
	// validator or jury yet.
	SlashingTx *BTCSlashingTx `protobuf:"bytes,9,opt,name=slashing_tx,json=slashingTx,proto3,customtype=BTCSlashingTx" json:"slashing_tx,omitempty"`
	// delegator_sig is the signature on the slashing tx
	// by the delegator (i.e., SK corresponding to btc_pk).
	// It will be a part of the witness for the staking tx output.
	DelegatorSig *github_com_babylonchain_babylon_types.BIP340Signature `protobuf:"bytes,10,opt,name=delegator_sig,json=delegatorSig,proto3,customtype=github.com/babylonchain/babylon/types.BIP340Signature" json:"delegator_sig,omitempty"`
	// jury_sig is the signature signature on the slashing tx
	// by the jury (i.e., SK corresponding to jury_pk in params)
	// It will be a part of the witness for the staking tx output.
	JurySig *github_com_babylonchain_babylon_types.BIP340Signature `protobuf:"bytes,11,opt,name=jury_sig,json=jurySig,proto3,customtype=github.com/babylonchain/babylon/types.BIP340Signature" json:"jury_sig,omitempty"`
	// if this object is present it menans that staker requested undelegation, and whole
	// delegation is being undelegated.
	// TODO: Consider whether it would be better to store it in separate store, and not
	// directly in delegation object
	BtcUndelegation *BTCUndelegation `protobuf:"bytes,12,opt,name=btc_undelegation,json=btcUndelegation,proto3" json:"btc_undelegation,omitempty"`
}

func (m *BTCDelegation) Reset()         { *m = BTCDelegation{} }
func (m *BTCDelegation) String() string { return proto.CompactTextString(m) }
func (*BTCDelegation) ProtoMessage()    {}
func (*BTCDelegation) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{2}
}
func (m *BTCDelegation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BTCDelegation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BTCDelegation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BTCDelegation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BTCDelegation.Merge(m, src)
}
func (m *BTCDelegation) XXX_Size() int {
	return m.Size()
}
func (m *BTCDelegation) XXX_DiscardUnknown() {
	xxx_messageInfo_BTCDelegation.DiscardUnknown(m)
}

var xxx_messageInfo_BTCDelegation proto.InternalMessageInfo

func (m *BTCDelegation) GetBabylonPk() *secp256k1.PubKey {
	if m != nil {
		return m.BabylonPk
	}
	return nil
}

func (m *BTCDelegation) GetPop() *ProofOfPossession {
	if m != nil {
		return m.Pop
	}
	return nil
}

func (m *BTCDelegation) GetStartHeight() uint64 {
	if m != nil {
		return m.StartHeight
	}
	return 0
}

func (m *BTCDelegation) GetEndHeight() uint64 {
	if m != nil {
		return m.EndHeight
	}
	return 0
}

func (m *BTCDelegation) GetTotalSat() uint64 {
	if m != nil {
		return m.TotalSat
	}
	return 0
}

func (m *BTCDelegation) GetStakingTx() *BabylonBTCTaprootTx {
	if m != nil {
		return m.StakingTx
	}
	return nil
}

func (m *BTCDelegation) GetBtcUndelegation() *BTCUndelegation {
	if m != nil {
		return m.BtcUndelegation
	}
	return nil
}

// BTCUndelegation signalizes that the delegation is being undelegated
type BTCUndelegation struct {
	// unbonding_tx is the transaction which will transfer the funds from staking
	// output to unbonding output. Unbonding output will usually have lower timelock
	// than staking output.
	UnbondingTx *BabylonBTCTaprootTx `protobuf:"bytes,1,opt,name=unbonding_tx,json=unbondingTx,proto3" json:"unbonding_tx,omitempty"`
	// slashing_tx is the slashing tx for unbodning transactions
	// It is partially signed by SK corresponding to btc_pk, but not signed by
	// validator or jury yet.
	SlashingTx *BTCSlashingTx `protobuf:"bytes,2,opt,name=slashing_tx,json=slashingTx,proto3,customtype=BTCSlashingTx" json:"slashing_tx,omitempty"`
	// delegator_slashing_sig is the signature on the slashing tx
	// by the delegator (i.e., SK corresponding to btc_pk).
	// It will be a part of the witness for the unbodning tx output.
	DelegatorSlashingSig *github_com_babylonchain_babylon_types.BIP340Signature `protobuf:"bytes,3,opt,name=delegator_slashing_sig,json=delegatorSlashingSig,proto3,customtype=github.com/babylonchain/babylon/types.BIP340Signature" json:"delegator_slashing_sig,omitempty"`
	// jury_slashing_sig is the signature on the slashing tx
	// by the jury (i.e., SK corresponding to jury_pk in params)
	// It must be provided after processing undelagate message by Babylon
	JurySlashingSig *github_com_babylonchain_babylon_types.BIP340Signature `protobuf:"bytes,4,opt,name=jury_slashing_sig,json=jurySlashingSig,proto3,customtype=github.com/babylonchain/babylon/types.BIP340Signature" json:"jury_slashing_sig,omitempty"`
	// jury_unbonding_sig is the signature on the unbonding tx
	// by the jury (i.e., SK corresponding to jury_pk in params)
	// It must be provided after processing undelagate message by Babylon and after
	// validator sig will be provided by validator
	JuryUnbondingSig *github_com_babylonchain_babylon_types.BIP340Signature `protobuf:"bytes,5,opt,name=jury_unbonding_sig,json=juryUnbondingSig,proto3,customtype=github.com/babylonchain/babylon/types.BIP340Signature" json:"jury_unbonding_sig,omitempty"`
	// validator_unbonding_sig is the signature on the unbonding tx
	// by the validator (i.e., SK corresponding to jury_pk in params)
	// It must be provided after processing undelagate message by Babylon
	ValidatorUnbondingSig *github_com_babylonchain_babylon_types.BIP340Signature `protobuf:"bytes,6,opt,name=validator_unbonding_sig,json=validatorUnbondingSig,proto3,customtype=github.com/babylonchain/babylon/types.BIP340Signature" json:"validator_unbonding_sig,omitempty"`
}

func (m *BTCUndelegation) Reset()         { *m = BTCUndelegation{} }
func (m *BTCUndelegation) String() string { return proto.CompactTextString(m) }
func (*BTCUndelegation) ProtoMessage()    {}
func (*BTCUndelegation) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{3}
}
func (m *BTCUndelegation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BTCUndelegation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BTCUndelegation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BTCUndelegation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BTCUndelegation.Merge(m, src)
}
func (m *BTCUndelegation) XXX_Size() int {
	return m.Size()
}
func (m *BTCUndelegation) XXX_DiscardUnknown() {
	xxx_messageInfo_BTCUndelegation.DiscardUnknown(m)
}

var xxx_messageInfo_BTCUndelegation proto.InternalMessageInfo

func (m *BTCUndelegation) GetUnbondingTx() *BabylonBTCTaprootTx {
	if m != nil {
		return m.UnbondingTx
	}
	return nil
}

// BTCUndelegationInfo provides all necessary info about the undeleagation
type BTCUndelegationInfo struct {
	// unbonding_tx is the transaction which will transfer the funds from staking
	// output to unbonding output. Unbonding output will usually have lower timelock
	// than staking output.
	UnbondingTx *BabylonBTCTaprootTx `protobuf:"bytes,1,opt,name=unbonding_tx,json=unbondingTx,proto3" json:"unbonding_tx,omitempty"`
	// validator_unbonding_sig is the signature on the unbonding tx
	// by the validator (i.e., SK corresponding to the pk of the validator that the staker delegates to)
	// It must be provided after processing undelagate message by Babylon
	// It will be nil if validator didn't sign it yet
	ValidatorUnbondingSig *github_com_babylonchain_babylon_types.BIP340Signature `protobuf:"bytes,2,opt,name=validator_unbonding_sig,json=validatorUnbondingSig,proto3,customtype=github.com/babylonchain/babylon/types.BIP340Signature" json:"validator_unbonding_sig,omitempty"`
	// jury_unbonding_sig is the signature on the unbonding tx
	// by the jury (i.e., SK corresponding to jury_pk in params)
	// it will be nil if jury didn't sign it yet
	JuryUnbondingSig *github_com_babylonchain_babylon_types.BIP340Signature `protobuf:"bytes,3,opt,name=jury_unbonding_sig,json=juryUnbondingSig,proto3,customtype=github.com/babylonchain/babylon/types.BIP340Signature" json:"jury_unbonding_sig,omitempty"`
}

func (m *BTCUndelegationInfo) Reset()         { *m = BTCUndelegationInfo{} }
func (m *BTCUndelegationInfo) String() string { return proto.CompactTextString(m) }
func (*BTCUndelegationInfo) ProtoMessage()    {}
func (*BTCUndelegationInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{4}
}
func (m *BTCUndelegationInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BTCUndelegationInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BTCUndelegationInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BTCUndelegationInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BTCUndelegationInfo.Merge(m, src)
}
func (m *BTCUndelegationInfo) XXX_Size() int {
	return m.Size()
}
func (m *BTCUndelegationInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BTCUndelegationInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BTCUndelegationInfo proto.InternalMessageInfo

func (m *BTCUndelegationInfo) GetUnbondingTx() *BabylonBTCTaprootTx {
	if m != nil {
		return m.UnbondingTx
	}
	return nil
}

// BTCDelegatorDelegations is a collection of BTC delegations, typically from the same delegator.
type BTCDelegatorDelegations struct {
	Dels []*BTCDelegation `protobuf:"bytes,1,rep,name=dels,proto3" json:"dels,omitempty"`
}

func (m *BTCDelegatorDelegations) Reset()         { *m = BTCDelegatorDelegations{} }
func (m *BTCDelegatorDelegations) String() string { return proto.CompactTextString(m) }
func (*BTCDelegatorDelegations) ProtoMessage()    {}
func (*BTCDelegatorDelegations) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{5}
}
func (m *BTCDelegatorDelegations) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BTCDelegatorDelegations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BTCDelegatorDelegations.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BTCDelegatorDelegations) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BTCDelegatorDelegations.Merge(m, src)
}
func (m *BTCDelegatorDelegations) XXX_Size() int {
	return m.Size()
}
func (m *BTCDelegatorDelegations) XXX_DiscardUnknown() {
	xxx_messageInfo_BTCDelegatorDelegations.DiscardUnknown(m)
}

var xxx_messageInfo_BTCDelegatorDelegations proto.InternalMessageInfo

func (m *BTCDelegatorDelegations) GetDels() []*BTCDelegation {
	if m != nil {
		return m.Dels
	}
	return nil
}

// ProofOfPossession is the proof of possession that a Babylon secp256k1
// secret key and a Bitcoin secp256k1 secret key are held by the same
// person
type ProofOfPossession struct {
	// babylon_sig is the signature generated via sign(sk_babylon, pk_btc)
	BabylonSig []byte `protobuf:"bytes,1,opt,name=babylon_sig,json=babylonSig,proto3" json:"babylon_sig,omitempty"`
	// btc_sig is the signature generated via sign(sk_btc, babylon_sig)
	// the signature follows encoding in BIP-340 spec
	BtcSig *github_com_babylonchain_babylon_types.BIP340Signature `protobuf:"bytes,2,opt,name=btc_sig,json=btcSig,proto3,customtype=github.com/babylonchain/babylon/types.BIP340Signature" json:"btc_sig,omitempty"`
}

func (m *ProofOfPossession) Reset()         { *m = ProofOfPossession{} }
func (m *ProofOfPossession) String() string { return proto.CompactTextString(m) }
func (*ProofOfPossession) ProtoMessage()    {}
func (*ProofOfPossession) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{6}
}
func (m *ProofOfPossession) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProofOfPossession) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProofOfPossession.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProofOfPossession) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProofOfPossession.Merge(m, src)
}
func (m *ProofOfPossession) XXX_Size() int {
	return m.Size()
}
func (m *ProofOfPossession) XXX_DiscardUnknown() {
	xxx_messageInfo_ProofOfPossession.DiscardUnknown(m)
}

var xxx_messageInfo_ProofOfPossession proto.InternalMessageInfo

func (m *ProofOfPossession) GetBabylonSig() []byte {
	if m != nil {
		return m.BabylonSig
	}
	return nil
}

// BabylonBtcTaprootTx is the bitcoin transaction which contains script recognized by Babylon and
// transaction which commits to the provided script.
type BabylonBTCTaprootTx struct {
	// tx is the transaction bytes
	Tx []byte `protobuf:"bytes,1,opt,name=tx,proto3" json:"tx,omitempty"`
	// script is the script recognized by Babylon
	Script []byte `protobuf:"bytes,2,opt,name=script,proto3" json:"script,omitempty"`
}

func (m *BabylonBTCTaprootTx) Reset()         { *m = BabylonBTCTaprootTx{} }
func (m *BabylonBTCTaprootTx) String() string { return proto.CompactTextString(m) }
func (*BabylonBTCTaprootTx) ProtoMessage()    {}
func (*BabylonBTCTaprootTx) Descriptor() ([]byte, []int) {
	return fileDescriptor_3851ae95ccfaf7db, []int{7}
}
func (m *BabylonBTCTaprootTx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BabylonBTCTaprootTx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BabylonBTCTaprootTx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BabylonBTCTaprootTx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BabylonBTCTaprootTx.Merge(m, src)
}
func (m *BabylonBTCTaprootTx) XXX_Size() int {
	return m.Size()
}
func (m *BabylonBTCTaprootTx) XXX_DiscardUnknown() {
	xxx_messageInfo_BabylonBTCTaprootTx.DiscardUnknown(m)
}

var xxx_messageInfo_BabylonBTCTaprootTx proto.InternalMessageInfo

func (m *BabylonBTCTaprootTx) GetTx() []byte {
	if m != nil {
		return m.Tx
	}
	return nil
}

func (m *BabylonBTCTaprootTx) GetScript() []byte {
	if m != nil {
		return m.Script
	}
	return nil
}

func init() {
	proto.RegisterEnum("babylon.btcstaking.v1.BTCDelegationStatus", BTCDelegationStatus_name, BTCDelegationStatus_value)
	proto.RegisterType((*BTCValidator)(nil), "babylon.btcstaking.v1.BTCValidator")
	proto.RegisterType((*BTCValidatorWithMeta)(nil), "babylon.btcstaking.v1.BTCValidatorWithMeta")
	proto.RegisterType((*BTCDelegation)(nil), "babylon.btcstaking.v1.BTCDelegation")
	proto.RegisterType((*BTCUndelegation)(nil), "babylon.btcstaking.v1.BTCUndelegation")
	proto.RegisterType((*BTCUndelegationInfo)(nil), "babylon.btcstaking.v1.BTCUndelegationInfo")
	proto.RegisterType((*BTCDelegatorDelegations)(nil), "babylon.btcstaking.v1.BTCDelegatorDelegations")
	proto.RegisterType((*ProofOfPossession)(nil), "babylon.btcstaking.v1.ProofOfPossession")
	proto.RegisterType((*BabylonBTCTaprootTx)(nil), "babylon.btcstaking.v1.BabylonBTCTaprootTx")
}

func init() {
	proto.RegisterFile("babylon/btcstaking/v1/btcstaking.proto", fileDescriptor_3851ae95ccfaf7db)
}

var fileDescriptor_3851ae95ccfaf7db = []byte{
	// 1012 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0x4d, 0x6f, 0x23, 0x45,
	0x13, 0xce, 0xd8, 0x8e, 0x13, 0x97, 0x9d, 0x37, 0x4e, 0x6f, 0x36, 0xeb, 0x77, 0x11, 0x76, 0xd6,
	0xac, 0x22, 0x6b, 0xc5, 0x8e, 0x49, 0xf6, 0x43, 0x0b, 0x12, 0x48, 0x4c, 0x1c, 0x41, 0xb4, 0x24,
	0x6b, 0xc6, 0x93, 0x05, 0x71, 0xc0, 0x9a, 0x8f, 0xce, 0x78, 0xb0, 0x33, 0x3d, 0x4c, 0xb7, 0x8d,
	0x7d, 0xe7, 0xc0, 0x91, 0x1b, 0x7f, 0x84, 0x1f, 0xc0, 0x71, 0x8f, 0x2b, 0x4e, 0x28, 0x87, 0x08,
	0x25, 0x7f, 0x04, 0x75, 0x4f, 0x8f, 0x3d, 0x49, 0xd6, 0x0b, 0xc1, 0xe6, 0x14, 0x77, 0x57, 0xd5,
	0x53, 0x55, 0xcf, 0x53, 0x99, 0x6a, 0xd8, 0xb2, 0x4c, 0x6b, 0xd4, 0x23, 0x7e, 0xdd, 0x62, 0x36,
	0x65, 0x66, 0xd7, 0xf3, 0xdd, 0xfa, 0x60, 0x3b, 0x71, 0x52, 0x83, 0x90, 0x30, 0x82, 0x6e, 0x4b,
	0x3f, 0x35, 0x61, 0x19, 0x6c, 0xdf, 0x5d, 0x77, 0x89, 0x4b, 0x84, 0x47, 0x9d, 0xff, 0x8a, 0x9c,
	0xef, 0xfe, 0xdf, 0x26, 0xf4, 0x84, 0xd0, 0x76, 0x64, 0x88, 0x0e, 0xd2, 0x54, 0x8d, 0x4e, 0x75,
	0x3b, 0x1c, 0x05, 0x8c, 0xd4, 0x29, 0xb6, 0x83, 0x9d, 0x27, 0x4f, 0xbb, 0xdb, 0xf5, 0x2e, 0x1e,
	0xc5, 0x3e, 0xf7, 0xa5, 0xcf, 0xa4, 0x1e, 0x0b, 0x33, 0x73, 0xbb, 0x7e, 0xa9, 0xa2, 0xea, 0x59,
	0x1a, 0x0a, 0x9a, 0xb1, 0xfb, 0xd2, 0xec, 0x79, 0x8e, 0xc9, 0x48, 0x88, 0xf6, 0x20, 0xef, 0x60,
	0x6a, 0x87, 0x5e, 0xc0, 0x3c, 0xe2, 0x97, 0x94, 0x4d, 0xa5, 0x96, 0xdf, 0x79, 0x4f, 0x95, 0xe9,
	0x27, 0x45, 0x0b, 0x30, 0xb5, 0x31, 0x71, 0xd5, 0x93, 0x71, 0xe8, 0x6b, 0x00, 0x9b, 0x9c, 0x9c,
	0x78, 0x94, 0x72, 0x94, 0xd4, 0xa6, 0x52, 0xcb, 0x69, 0xcf, 0x4e, 0xcf, 0x2a, 0x5b, 0xae, 0xc7,
	0x3a, 0x7d, 0x4b, 0xb5, 0xc9, 0x49, 0x3d, 0x6e, 0x42, 0xfc, 0x79, 0x48, 0x9d, 0x6e, 0x9d, 0x8d,
	0x02, 0x4c, 0xd5, 0x06, 0xb6, 0x7f, 0xff, 0xf5, 0x21, 0xc8, 0x94, 0x0d, 0x6c, 0xeb, 0x09, 0x2c,
	0xf4, 0x09, 0x80, 0x64, 0xb1, 0x1d, 0x74, 0x4b, 0x69, 0x51, 0x5f, 0x25, 0xae, 0x2f, 0x22, 0x44,
	0x1d, 0x13, 0xa2, 0x36, 0xfb, 0xd6, 0x73, 0x3c, 0xd2, 0x73, 0x32, 0xa4, 0xd9, 0x45, 0x07, 0x90,
	0xb5, 0x98, 0xcd, 0x63, 0x33, 0x9b, 0x4a, 0xad, 0xa0, 0x3d, 0x3d, 0x3d, 0xab, 0xec, 0x24, 0xaa,
	0x92, 0x9e, 0x76, 0xc7, 0xf4, 0xfc, 0xf8, 0x20, 0x0b, 0xd3, 0xf6, 0x9b, 0x8f, 0x1e, 0x7f, 0x20,
	0x21, 0x17, 0x2d, 0x66, 0x37, 0xbb, 0xe8, 0x23, 0x48, 0x07, 0x24, 0x28, 0x2d, 0x8a, 0x3a, 0x6a,
	0xea, 0x1b, 0x05, 0x56, 0x9b, 0x21, 0x21, 0xc7, 0x2f, 0x8e, 0x9b, 0x84, 0x52, 0x2c, 0xba, 0xd0,
	0x79, 0x10, 0x7a, 0x0c, 0x1b, 0xb4, 0x67, 0xd2, 0x0e, 0x76, 0xda, 0x71, 0x4b, 0x1d, 0xec, 0xb9,
	0x1d, 0x56, 0xca, 0x6e, 0x2a, 0xb5, 0x8c, 0xbe, 0x2e, 0xad, 0x5a, 0x64, 0xfc, 0x5c, 0xd8, 0xd0,
	0xfb, 0x80, 0xc6, 0x51, 0xcc, 0x8e, 0x23, 0x96, 0x44, 0x44, 0x31, 0x8e, 0x60, 0x76, 0xe4, 0x5d,
	0xfd, 0x31, 0x05, 0xeb, 0x49, 0x81, 0xbf, 0xf2, 0x58, 0xe7, 0x00, 0x33, 0x33, 0xc1, 0x83, 0x32,
	0x0f, 0x1e, 0x36, 0x20, 0x2b, 0x2b, 0x49, 0x89, 0x4a, 0xe4, 0x09, 0xdd, 0x83, 0xc2, 0x80, 0x30,
	0xcf, 0x77, 0xdb, 0x01, 0xf9, 0x01, 0x87, 0x42, 0xb0, 0x8c, 0x9e, 0x8f, 0xee, 0x9a, 0xfc, 0xea,
	0x2d, 0x34, 0x64, 0x6e, 0x4c, 0xc3, 0xe2, 0x14, 0x1a, 0x7e, 0xc9, 0xc2, 0x8a, 0x66, 0xec, 0x36,
	0x70, 0x0f, 0xbb, 0x26, 0xbb, 0x3e, 0x47, 0xca, 0x0c, 0x73, 0x94, 0x9a, 0xe3, 0x1c, 0xa5, 0xff,
	0xcd, 0x1c, 0x19, 0x00, 0x03, 0xb3, 0xd7, 0x9e, 0xcb, 0x58, 0x2f, 0x0f, 0xcc, 0x9e, 0x26, 0x2a,
	0xba, 0x07, 0x05, 0xca, 0xcc, 0x90, 0x5d, 0xa6, 0x36, 0x2f, 0xee, 0xa4, 0x06, 0xef, 0x02, 0x60,
	0xdf, 0xb9, 0x3c, 0xb4, 0x39, 0xec, 0x3b, 0xd2, 0xfc, 0x0e, 0xe4, 0x18, 0x61, 0x66, 0xaf, 0x4d,
	0xcd, 0x78, 0x40, 0x97, 0xc5, 0x45, 0xcb, 0x64, 0x68, 0x1f, 0x40, 0x76, 0xd6, 0x66, 0xc3, 0xd2,
	0xb2, 0xe8, 0xfb, 0xc1, 0x94, 0xbe, 0xa5, 0xf2, 0x9a, 0xb1, 0x6b, 0x98, 0x41, 0x48, 0x08, 0x33,
	0x86, 0x7a, 0x4e, 0xda, 0x8d, 0x21, 0xda, 0x81, 0xbc, 0x10, 0x5c, 0x62, 0xe5, 0x04, 0x01, 0x6b,
	0xa7, 0x67, 0x15, 0x2e, 0x79, 0x4b, 0x5a, 0x8c, 0xa1, 0x0e, 0x74, 0xfc, 0x1b, 0x7d, 0x0b, 0x2b,
	0x4e, 0x34, 0x0c, 0x24, 0x6c, 0x53, 0xcf, 0x2d, 0x81, 0x88, 0xfa, 0xf0, 0xf4, 0xac, 0xf2, 0xe4,
	0x26, 0xb4, 0xb5, 0x3c, 0xd7, 0x37, 0x59, 0x3f, 0xc4, 0x7a, 0x61, 0x8c, 0xd7, 0xf2, 0x5c, 0x64,
	0xc0, 0xf2, 0x77, 0xfd, 0x70, 0x24, 0xa0, 0xf3, 0xb3, 0x42, 0x2f, 0x71, 0x28, 0x8e, 0xfa, 0x25,
	0x14, 0xb9, 0xca, 0x7d, 0xdf, 0x19, 0x0f, 0x72, 0xa9, 0x20, 0xa8, 0xdb, 0x9a, 0x46, 0x9d, 0xb1,
	0x7b, 0x94, 0xf0, 0xd6, 0x57, 0x2d, 0x66, 0x27, 0x2f, 0xaa, 0xaf, 0x32, 0xb0, 0x7a, 0xc5, 0x09,
	0x1d, 0x40, 0xa1, 0xef, 0x5b, 0xc4, 0x77, 0x24, 0xa3, 0xca, 0x8d, 0xd5, 0xc9, 0x8f, 0xe3, 0xaf,
	0xeb, 0x93, 0xfa, 0x27, 0xfa, 0x10, 0xd8, 0x48, 0xe8, 0x13, 0x47, 0x73, 0x36, 0xd3, 0xb3, 0xb2,
	0xb9, 0x3e, 0x11, 0x4a, 0xe2, 0x72, 0x6a, 0x31, 0xac, 0x45, 0x82, 0x25, 0x73, 0x65, 0x66, 0xcd,
	0xb5, 0x2a, 0x94, 0x4b, 0xa4, 0x71, 0x01, 0x89, 0x34, 0x13, 0x7e, 0x79, 0x9e, 0xc5, 0x59, 0xf3,
	0x14, 0x39, 0xe8, 0x51, 0x8c, 0xc9, 0x13, 0x7d, 0x0f, 0x77, 0x06, 0xf1, 0x47, 0xff, 0x4a, 0xb6,
	0xec, 0xac, 0xd9, 0x6e, 0x8f, 0x91, 0x93, 0x29, 0xab, 0xbf, 0xa5, 0xe0, 0xd6, 0x95, 0x51, 0xda,
	0xf7, 0x8f, 0xc9, 0xbc, 0xc7, 0xe9, 0x2d, 0x9d, 0xa5, 0xfe, 0x9b, 0xce, 0xa6, 0xa8, 0x96, 0x9e,
	0xbb, 0x6a, 0xd5, 0x16, 0xdc, 0x99, 0xac, 0x29, 0x12, 0x4e, 0xf6, 0x15, 0x45, 0xcf, 0x20, 0xe3,
	0xe0, 0x1e, 0x2d, 0x29, 0x9b, 0xe9, 0x5a, 0x7e, 0xe7, 0xfe, 0xf4, 0xff, 0xf7, 0x49, 0x90, 0x2e,
	0x22, 0xaa, 0x3f, 0x29, 0xb0, 0x76, 0x6d, 0x75, 0xa0, 0x0a, 0xe4, 0xe3, 0x05, 0xc8, 0x9b, 0x11,
	0xaf, 0x00, 0x3d, 0xde, 0x89, 0xbc, 0x69, 0x1d, 0x96, 0xf8, 0xc7, 0x66, 0x2e, 0xbc, 0xf2, 0x5d,
	0xc9, 0xfb, 0xfb, 0x18, 0x6e, 0xbd, 0x41, 0x5f, 0xf4, 0x3f, 0x48, 0xc9, 0xb9, 0x28, 0xe8, 0x29,
	0x36, 0xe4, 0xaf, 0x89, 0xe8, 0x2d, 0x19, 0x65, 0xd6, 0xe5, 0xe9, 0xc1, 0x73, 0x31, 0x60, 0x93,
	0x06, 0x5b, 0xcc, 0x64, 0x7d, 0x8a, 0xf2, 0xb0, 0xd4, 0xdc, 0x3b, 0x6c, 0xec, 0x1f, 0x7e, 0x56,
	0x5c, 0x40, 0x00, 0xd9, 0x4f, 0x77, 0x8d, 0xfd, 0x97, 0x7b, 0x45, 0x05, 0xad, 0x40, 0xee, 0xe8,
	0x50, 0x7b, 0x11, 0x99, 0x52, 0xa8, 0x00, 0xcb, 0xd1, 0x71, 0xaf, 0x51, 0x4c, 0x6b, 0x5f, 0xbc,
	0x3a, 0x2f, 0x2b, 0xaf, 0xcf, 0xcb, 0xca, 0x9f, 0xe7, 0x65, 0xe5, 0xe7, 0x8b, 0xf2, 0xc2, 0xeb,
	0x8b, 0xf2, 0xc2, 0x1f, 0x17, 0xe5, 0x85, 0x6f, 0xfe, 0x76, 0x71, 0x0e, 0x93, 0x2f, 0x7d, 0xd1,
	0xb1, 0x95, 0x15, 0x0f, 0xea, 0x47, 0x7f, 0x05, 0x00, 0x00, 0xff, 0xff, 0x25, 0xa9, 0x4e, 0x2a,
	0x0c, 0x0c, 0x00, 0x00,
}

func (m *BTCValidator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BTCValidator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCValidator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SlashedBtcHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.SlashedBtcHeight))
		i--
		dAtA[i] = 0x38
	}
	if m.SlashedBabylonHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.SlashedBabylonHeight))
		i--
		dAtA[i] = 0x30
	}
	if m.Pop != nil {
		{
			size, err := m.Pop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.BtcPk != nil {
		{
			size := m.BtcPk.Size()
			i -= size
			if _, err := m.BtcPk.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.BabylonPk != nil {
		{
			size, err := m.BabylonPk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Commission != nil {
		{
			size := m.Commission.Size()
			i -= size
			if _, err := m.Commission.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Description != nil {
		{
			size, err := m.Description.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BTCValidatorWithMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BTCValidatorWithMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCValidatorWithMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SlashedBtcHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.SlashedBtcHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.SlashedBabylonHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.SlashedBabylonHeight))
		i--
		dAtA[i] = 0x20
	}
	if m.VotingPower != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.VotingPower))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.BtcPk != nil {
		{
			size := m.BtcPk.Size()
			i -= size
			if _, err := m.BtcPk.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BTCDelegation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BTCDelegation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCDelegation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BtcUndelegation != nil {
		{
			size, err := m.BtcUndelegation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.JurySig != nil {
		{
			size := m.JurySig.Size()
			i -= size
			if _, err := m.JurySig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.DelegatorSig != nil {
		{
			size := m.DelegatorSig.Size()
			i -= size
			if _, err := m.DelegatorSig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.SlashingTx != nil {
		{
			size := m.SlashingTx.Size()
			i -= size
			if _, err := m.SlashingTx.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.StakingTx != nil {
		{
			size, err := m.StakingTx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.TotalSat != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.TotalSat))
		i--
		dAtA[i] = 0x38
	}
	if m.EndHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.EndHeight))
		i--
		dAtA[i] = 0x30
	}
	if m.StartHeight != 0 {
		i = encodeVarintBtcstaking(dAtA, i, uint64(m.StartHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.ValBtcPk != nil {
		{
			size := m.ValBtcPk.Size()
			i -= size
			if _, err := m.ValBtcPk.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Pop != nil {
		{
			size, err := m.Pop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.BtcPk != nil {
		{
			size := m.BtcPk.Size()
			i -= size
			if _, err := m.BtcPk.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.BabylonPk != nil {
		{
			size, err := m.BabylonPk.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BTCUndelegation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BTCUndelegation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCUndelegation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ValidatorUnbondingSig != nil {
		{
			size := m.ValidatorUnbondingSig.Size()
			i -= size
			if _, err := m.ValidatorUnbondingSig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.JuryUnbondingSig != nil {
		{
			size := m.JuryUnbondingSig.Size()
			i -= size
			if _, err := m.JuryUnbondingSig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.JurySlashingSig != nil {
		{
			size := m.JurySlashingSig.Size()
			i -= size
			if _, err := m.JurySlashingSig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.DelegatorSlashingSig != nil {
		{
			size := m.DelegatorSlashingSig.Size()
			i -= size
			if _, err := m.DelegatorSlashingSig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.SlashingTx != nil {
		{
			size := m.SlashingTx.Size()
			i -= size
			if _, err := m.SlashingTx.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.UnbondingTx != nil {
		{
			size, err := m.UnbondingTx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BTCUndelegationInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BTCUndelegationInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCUndelegationInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.JuryUnbondingSig != nil {
		{
			size := m.JuryUnbondingSig.Size()
			i -= size
			if _, err := m.JuryUnbondingSig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ValidatorUnbondingSig != nil {
		{
			size := m.ValidatorUnbondingSig.Size()
			i -= size
			if _, err := m.ValidatorUnbondingSig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.UnbondingTx != nil {
		{
			size, err := m.UnbondingTx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BTCDelegatorDelegations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BTCDelegatorDelegations) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BTCDelegatorDelegations) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Dels) > 0 {
		for iNdEx := len(m.Dels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Dels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBtcstaking(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ProofOfPossession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProofOfPossession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProofOfPossession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BtcSig != nil {
		{
			size := m.BtcSig.Size()
			i -= size
			if _, err := m.BtcSig.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
			i = encodeVarintBtcstaking(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.BabylonSig) > 0 {
		i -= len(m.BabylonSig)
		copy(dAtA[i:], m.BabylonSig)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.BabylonSig)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BabylonBTCTaprootTx) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BabylonBTCTaprootTx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BabylonBTCTaprootTx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Script) > 0 {
		i -= len(m.Script)
		copy(dAtA[i:], m.Script)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.Script)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Tx) > 0 {
		i -= len(m.Tx)
		copy(dAtA[i:], m.Tx)
		i = encodeVarintBtcstaking(dAtA, i, uint64(len(m.Tx)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintBtcstaking(dAtA []byte, offset int, v uint64) int {
	offset -= sovBtcstaking(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BTCValidator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Description != nil {
		l = m.Description.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.Commission != nil {
		l = m.Commission.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.BabylonPk != nil {
		l = m.BabylonPk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.BtcPk != nil {
		l = m.BtcPk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.Pop != nil {
		l = m.Pop.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.SlashedBabylonHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.SlashedBabylonHeight))
	}
	if m.SlashedBtcHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.SlashedBtcHeight))
	}
	return n
}

func (m *BTCValidatorWithMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BtcPk != nil {
		l = m.BtcPk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovBtcstaking(uint64(m.Height))
	}
	if m.VotingPower != 0 {
		n += 1 + sovBtcstaking(uint64(m.VotingPower))
	}
	if m.SlashedBabylonHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.SlashedBabylonHeight))
	}
	if m.SlashedBtcHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.SlashedBtcHeight))
	}
	return n
}

func (m *BTCDelegation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BabylonPk != nil {
		l = m.BabylonPk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.BtcPk != nil {
		l = m.BtcPk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.Pop != nil {
		l = m.Pop.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.ValBtcPk != nil {
		l = m.ValBtcPk.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.StartHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.StartHeight))
	}
	if m.EndHeight != 0 {
		n += 1 + sovBtcstaking(uint64(m.EndHeight))
	}
	if m.TotalSat != 0 {
		n += 1 + sovBtcstaking(uint64(m.TotalSat))
	}
	if m.StakingTx != nil {
		l = m.StakingTx.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.SlashingTx != nil {
		l = m.SlashingTx.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.DelegatorSig != nil {
		l = m.DelegatorSig.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.JurySig != nil {
		l = m.JurySig.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.BtcUndelegation != nil {
		l = m.BtcUndelegation.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func (m *BTCUndelegation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnbondingTx != nil {
		l = m.UnbondingTx.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.SlashingTx != nil {
		l = m.SlashingTx.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.DelegatorSlashingSig != nil {
		l = m.DelegatorSlashingSig.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.JurySlashingSig != nil {
		l = m.JurySlashingSig.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.JuryUnbondingSig != nil {
		l = m.JuryUnbondingSig.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.ValidatorUnbondingSig != nil {
		l = m.ValidatorUnbondingSig.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func (m *BTCUndelegationInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnbondingTx != nil {
		l = m.UnbondingTx.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.ValidatorUnbondingSig != nil {
		l = m.ValidatorUnbondingSig.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.JuryUnbondingSig != nil {
		l = m.JuryUnbondingSig.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func (m *BTCDelegatorDelegations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Dels) > 0 {
		for _, e := range m.Dels {
			l = e.Size()
			n += 1 + l + sovBtcstaking(uint64(l))
		}
	}
	return n
}

func (m *ProofOfPossession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BabylonSig)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	if m.BtcSig != nil {
		l = m.BtcSig.Size()
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func (m *BabylonBTCTaprootTx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tx)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	l = len(m.Script)
	if l > 0 {
		n += 1 + l + sovBtcstaking(uint64(l))
	}
	return n
}

func sovBtcstaking(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBtcstaking(x uint64) (n int) {
	return sovBtcstaking(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BTCValidator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BTCValidator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BTCValidator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Description == nil {
				m.Description = &types.Description{}
			}
			if err := m.Description.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_cosmos_cosmos_sdk_types.Dec
			m.Commission = &v
			if err := m.Commission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BabylonPk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BabylonPk == nil {
				m.BabylonPk = &secp256k1.PubKey{}
			}
			if err := m.BabylonPk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcPk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340PubKey
			m.BtcPk = &v
			if err := m.BtcPk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pop == nil {
				m.Pop = &ProofOfPossession{}
			}
			if err := m.Pop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashedBabylonHeight", wireType)
			}
			m.SlashedBabylonHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashedBabylonHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashedBtcHeight", wireType)
			}
			m.SlashedBtcHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashedBtcHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BTCValidatorWithMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BTCValidatorWithMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BTCValidatorWithMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcPk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340PubKey
			m.BtcPk = &v
			if err := m.BtcPk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotingPower", wireType)
			}
			m.VotingPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VotingPower |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashedBabylonHeight", wireType)
			}
			m.SlashedBabylonHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashedBabylonHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashedBtcHeight", wireType)
			}
			m.SlashedBtcHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashedBtcHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BTCDelegation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BTCDelegation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BTCDelegation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BabylonPk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BabylonPk == nil {
				m.BabylonPk = &secp256k1.PubKey{}
			}
			if err := m.BabylonPk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcPk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340PubKey
			m.BtcPk = &v
			if err := m.BtcPk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pop == nil {
				m.Pop = &ProofOfPossession{}
			}
			if err := m.Pop.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValBtcPk", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340PubKey
			m.ValBtcPk = &v
			if err := m.ValBtcPk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartHeight", wireType)
			}
			m.StartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndHeight", wireType)
			}
			m.EndHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSat", wireType)
			}
			m.TotalSat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSat |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakingTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StakingTx == nil {
				m.StakingTx = &BabylonBTCTaprootTx{}
			}
			if err := m.StakingTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashingTx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v BTCSlashingTx
			m.SlashingTx = &v
			if err := m.SlashingTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340Signature
			m.DelegatorSig = &v
			if err := m.DelegatorSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JurySig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340Signature
			m.JurySig = &v
			if err := m.JurySig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcUndelegation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BtcUndelegation == nil {
				m.BtcUndelegation = &BTCUndelegation{}
			}
			if err := m.BtcUndelegation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BTCUndelegation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BTCUndelegation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BTCUndelegation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnbondingTx == nil {
				m.UnbondingTx = &BabylonBTCTaprootTx{}
			}
			if err := m.UnbondingTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashingTx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v BTCSlashingTx
			m.SlashingTx = &v
			if err := m.SlashingTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorSlashingSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340Signature
			m.DelegatorSlashingSig = &v
			if err := m.DelegatorSlashingSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JurySlashingSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340Signature
			m.JurySlashingSig = &v
			if err := m.JurySlashingSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JuryUnbondingSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340Signature
			m.JuryUnbondingSig = &v
			if err := m.JuryUnbondingSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorUnbondingSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340Signature
			m.ValidatorUnbondingSig = &v
			if err := m.ValidatorUnbondingSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BTCUndelegationInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BTCUndelegationInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BTCUndelegationInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnbondingTx == nil {
				m.UnbondingTx = &BabylonBTCTaprootTx{}
			}
			if err := m.UnbondingTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorUnbondingSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340Signature
			m.ValidatorUnbondingSig = &v
			if err := m.ValidatorUnbondingSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JuryUnbondingSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340Signature
			m.JuryUnbondingSig = &v
			if err := m.JuryUnbondingSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BTCDelegatorDelegations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BTCDelegatorDelegations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BTCDelegatorDelegations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dels = append(m.Dels, &BTCDelegation{})
			if err := m.Dels[len(m.Dels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProofOfPossession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProofOfPossession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProofOfPossession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BabylonSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BabylonSig = append(m.BabylonSig[:0], dAtA[iNdEx:postIndex]...)
			if m.BabylonSig == nil {
				m.BabylonSig = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BtcSig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var v github_com_babylonchain_babylon_types.BIP340Signature
			m.BtcSig = &v
			if err := m.BtcSig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BabylonBTCTaprootTx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BabylonBTCTaprootTx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BabylonBTCTaprootTx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tx = append(m.Tx[:0], dAtA[iNdEx:postIndex]...)
			if m.Tx == nil {
				m.Tx = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Script", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBtcstaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Script = append(m.Script[:0], dAtA[iNdEx:postIndex]...)
			if m.Script == nil {
				m.Script = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBtcstaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBtcstaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBtcstaking(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBtcstaking
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBtcstaking
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBtcstaking
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBtcstaking
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBtcstaking
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBtcstaking        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBtcstaking          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBtcstaking = fmt.Errorf("proto: unexpected end of group")
)
